#!/usr/bin/perl -w
#use packages
use FindBin qw($Bin);
use lib "$Bin/lib";
use lib "$Bin/share";
use XML::LibXML;
use IO::Handle;
use warnings;
use strict;
use File::Spec;
use File::Basename;
# initialize the parser
my $parser = new XML::LibXML;

# open a filehandle and parse
my $fh = new IO::Handle;

my $nameinH = "";
my $productN = "";
my $panel_compatibe = "";
my @Headers;
#my @EFFECT;
my @LCDEnum;
my @LCDMap;

my $fail_error_hdr = "make[0]: *** FATAL ERROR: ";
my $panel_xml_file = "../panel";
my $kernel_include_folder = $ARGV[0];

#Execution start time
my $start_time = time;

# get the abs path for tools folder so that we can copy the 
# files with the relative path, the tool will execute in this
# folder
my $abs_path = File::Spec->rel2abs($0);
$abs_path = dirname($abs_path);
chdir $abs_path;

#get list of all xml files
my @files = glob("$panel_xml_file/*.xml");

#remove old kernel files
my @temp = glob("$kernel_include_folder/hw_lcd_effect_*.h");
for (@temp) {
	unlink $_;
}

@temp = glob("$kernel_include_folder/hw_lcd_effects.h");
for (@temp) {
	unlink $_;
}

@temp = glob("$kernel_include_folder/hw_lcd_ext.h");
for (@temp) {
	unlink $_;
}

foreach my $file (@files) {
	print "parsing $file\n";
	system("./localperl/bin/perl parser_effect_h.pl ".$file." panel");

	if ($?) {
		die "$fail_error_hdr Failed to parse file: $file!\n";
	}

	my $xmldoc = $parser->parse_file($file);

	for my $property($xmldoc->findnodes('/GCDB/PanelH'))
	{
		$nameinH = $property->textContent();
	}

	#move the header file to kernel folder to compile kernel
	my $lcd_file = 'hw_lcd_effect_' . $nameinH . ".h";
	system("mv ".$lcd_file." $kernel_include_folder/".$lcd_file);
	if ($?) {
		die "$fail_error_hdr Failed to move file: $file!\n";
	}

	#save vars to process it later
	push(@Headers, $lcd_file);
	#push(@EFFECT, $lcd_file);
	push(@LCDEnum, uc($nameinH));

	for my $property($xmldoc->findnodes('/GCDB/PanelEntry/PanelCompatible'))
	{
		$panel_compatibe = $property->textContent();
	}
	push(@LCDMap, uc($nameinH)."_PANEL, ".$panel_compatibe);
}

open (my $LCDEFFECTH, ">$kernel_include_folder/hw_lcd_effects.h") or die $fail_error_hdr.$!;
open (my $LCDEXTH, ">$kernel_include_folder/hw_lcd_ext.h") or die $fail_error_hdr.$!;
#add autogen header to header file
printheader($LCDEFFECTH);
printheader($LCDEXTH);

#add header safe guard
print $LCDEFFECTH "\n#ifndef _HW_LCD_EFFECT_H_\n";
print $LCDEFFECTH "\n#define _HW_LCD_EFFECT_H_\n\n";

print $LCDEXTH "\n#ifndef _HW_LCD_EXT_H_\n";
print $LCDEXTH "\n#define _HW_LCD_EXT_H_\n\n";
#print $PANELH "#include \"panel_nt35521_720p_video.h\"\n";
#include all the headers created by the xml files
my $file;
print $LCDEFFECTH "#include \"hw_lcd_ext.h\"\n";
foreach $file (@Headers) {
	print $LCDEFFECTH "#include \"".$file."\"\n";
}

#print enum for LCD Effect ID
printlcdeffectenum($LCDEXTH, \@LCDEnum);

#print LCD Effect Map structure
printeffectstructure($LCDEXTH, \@LCDMap);

#lcd effect enum selection function
printlcdeffectselectfunc($LCDEFFECTH, \@LCDEnum);

#select the LCD Effect based on panel compatible
printlcdeffectmapfunc($LCDEXTH);

#add header safe guard
print $LCDEFFECTH "\n#endif /*_HW_LCD_EFFECT_H_*/\n";
print $LCDEXTH "\n#endif /*_HW_LCD_EXT_H_*/\n";

exit 0;

#Function to truncate and recreate the dtsi file if not recent

sub printheader
{
	my $fh = shift;
	print $fh "/*---------------------------------------------------------------------------\n";
	print $fh " * This file is autogenerated file using huawei LCD parser. Please do not edit it.\n";
	print $fh " * Update input XML file to add a new entry or update variable in this file\n";
	print $fh " * Parser location: device/hisilicon/common/display/tools/huawei_lcd_panel \n";
	print $fh " *---------------------------------------------------------------------------*/\n\n";
}

sub printlcdenum
{
	my $fh = shift;
	my $list = shift;
	my $lcdenum;
	print $fh "\n/*---------------------------------------------------------------------------*/\n";
	print $fh "/* static panel selection variable                                           */\n";
	print $fh "/*---------------------------------------------------------------------------*/\n";
	print $fh "enum {\n";

	foreach $lcdenum (@$list) {
		print $fh $lcdenum."_PANEL,\n";
	}

#	print $fh $lk_default_panel."_PANEL,\n";
	print $fh "};\n\n";
}

sub printlcdeffectenum
{
	my $fh = shift;
	my $list = shift;
	my $lcdenum;
	print $fh "\n/*---------------------------------------------------------------------------*/\n";
	print $fh "/* static lcd effect selection variable                                           */\n";
	print $fh "/*---------------------------------------------------------------------------*/\n";
	print $fh "enum {\n";

	foreach $lcdenum (@$list) {
		print $fh $lcdenum."_PANEL,\n";
	}

#	print $fh $lk_default_panel."_PANEL,\n";
	print $fh "};\n\n";
}

sub printstructure
{
	my $fh = shift;
	my $list = shift;
	my $lcdmap;
	print $fh "\n/*---------------------------------------------------------------------------*/\n";
	print $fh "/* static panel board mapping variable                                           */\n";
	print $fh "/*---------------------------------------------------------------------------*/\n";
	print $fh "struct hw_lcd_board_map {\n";
	print $fh "\tuint8_t lcd_id;\n";
	print $fh "\tuint8_t gpio_id;\n";
	print $fh "\tuint16_t board_id;\n";
	print $fh "};\n\n";

	print $fh "static struct hw_lcd_board_map lcd_map[] = {\n";

	foreach $lcdmap (@$list) {
		print $fh "\t{".$lcdmap."},\n";
	}

	print $fh "};\n\n";
}

sub printeffectstructure
{
	my $fh = shift;
	my $list = shift;
	my $lcdmap;
	print $fh "\n/*---------------------------------------------------------------------------*/\n";
	print $fh "/* static lcd mapping variable                                           */\n";
	print $fh "/*---------------------------------------------------------------------------*/\n";
	print $fh "struct hw_lcd_map {\n";
	print $fh "\tu32 lcd_id;\n";
	print $fh "\tchar* panel_name;\n";
	print $fh "};\n\n";

	print $fh "static struct hw_lcd_map lcd_map[] = {\n";

	foreach $lcdmap (@$list) {
		print $fh "\t{".$lcdmap."},\n";
	}

	print $fh "};\n\n";
}

sub printlcdselectionfunc
{
	my $fh = shift;
	my $enum = shift;
	my $i;

	print $fh "static bool hw_init_panel_data(struct panel_data *paneldata,\n";
	print $fh "			struct dsi_panel_cmd *on_cmds,\n";
	print $fh "			struct dsi_panel_cmd *off_cmds,\n";
	print $fh "			uint8_t panel_id)\n";
	print $fh "{\n";
	print $fh "\tswitch (panel_id) {\n";

	for $i ( 0 ..  scalar(@$enum)-1 ) {
		print $fh "\tcase ".@$enum[$i]."_PANEL:\n";
		printlcdconfig($fh, @$enum[$i]);
	}

#	print $fh "\tcase ".$lk_default_panel."_PANEL:\n";
#	printlcdconfig($fh, $lk_default_panel);

	print $fh "\tdefault:\n";
	print $fh "\t\t".'PRINT_INFO("Panel ID not detected %d\n", panel_id);'."\n";
	print $fh "\t\treturn FALSE;\n";
	print $fh "\t}\n\n";
	print $fh "\treturn TRUE;\n";
	print $fh "}\n\n";
}

sub printlcdeffectselectfunc
{
	my $fh = shift;
	my $enum = shift;
	my $i;

	print $fh "static void hw_lcd_effect_get_data(uint8_t panel_id, struct hisi_panel_info* pinfo)\n";
	print $fh "{\n";
	print $fh "\tswitch (panel_id) {\n";

	for $i ( 0 ..  scalar(@$enum)-1 ) {
		print $fh "\tcase ".@$enum[$i]."_PANEL:\n";
		printlcdeffectconfig($fh, @$enum[$i]);
	}

#	print $fh "\tcase ".$lk_default_panel."_PANEL:\n";
#	printlcdconfig($fh, $lk_default_panel);

	print $fh "\tdefault:\n";
	print $fh "\t\t".'HISI_FB_INFO("Panel ID not detected %d\n", panel_id);'."\n";
	print $fh "\t\tbreak;\n";
	print $fh "\t}\n";
	print $fh "}\n\n";
}

sub printlcdconfig
{
	my $fh = shift;
	my $name = shift;
	print $fh "\t\tpaneldata->panel     = &".lc($name)."_panel_info;\n";
	print $fh "\t\tpaneldata->ldi        = &".lc($name)."_ldi_panel_info;\n";
	print $fh "\t\tpaneldata->smart_bl   = &".lc($name)."_sbl_panel_info;\n";
	print $fh "\t\tpaneldata->mipi = &".lc($name)."_mipi_panel_info;\n";
#	print $fh "\t\tpaneldata->dirty_region_info = &".lc($name)."_dirty_region_info;\n";
#	print $fh "\t\tpanelstruct->state        = &".lc($name)."_state;\n";
#	print $fh "\t\tpanelstruct->laneconfig   = &".lc($name)."_lane_config;\n";
#	print $fh "\t\tpanelstruct->paneltiminginfo	= &".lc($name)."_timing_info;\n";
#	print $fh "\t\tpanelstruct->panelresetseq = &".lc($name)."_reset_seq;\n";
#	print $fh "\t\tpanelstruct->backlight = &".lc($name)."_backlight;\n";
	print $fh "\t\ton_cmds->panel_cmds	 = ".lc($name)."_on_cmds;\n";
	print $fh "\t\ton_cmds->cmd_cnt = ARRAY_SIZE(".lc($name)."_on_cmds);\n";
	print $fh "\t\toff_cmds->panel_cmds	 = ".lc($name)."_off_cmds;\n";
	print $fh "\t\toff_cmds->cmd_cnt = ARRAY_SIZE(".lc($name)."_off_cmds);\n";
#	print $fh "\t\tmemcpy(phy_db->timing, ".lc($name)."_timings, TIMING_SIZE);\n";
	print $fh "\t\tbreak;\n\n"
}

sub printlcdeffectconfig
{
	my $fh = shift;
	my $name = shift;
	print $fh "\t\tif (pinfo->acm_support == 1)\n";
	print $fh "\t\t{\n";
	print $fh "\t\t\tpinfo->acm_lut_hue_table = " . lc($name) . "_acm_lut_hue_table;\n";
	print $fh "\t\t\tpinfo->acm_lut_hue_table_len = ARRAY_SIZE(" . lc($name) . "_acm_lut_hue_table);\n";
	print $fh "\t\t\tpinfo->acm_lut_sata_table = " . lc($name) . "_acm_lut_sata_table;\n";
	print $fh "\t\t\tpinfo->acm_lut_sata_table_len = ARRAY_SIZE(" . lc($name) . "_acm_lut_sata_table);\n";
	print $fh "\t\t\tpinfo->acm_lut_satr_table = " . lc($name) . "_acm_lut_satr_table;\n";
	print $fh "\t\t\tpinfo->acm_lut_satr_table_len = ARRAY_SIZE(" . lc($name) . "_acm_lut_satr_table);\n";
	print $fh "\t\t}\n";
	
	print $fh "\t\tif (pinfo->gamma_support == 1)\n";
	print $fh "\t\t{\n";
	print $fh "\t\t\tpinfo->gamma_lut_table_R = " . lc($name) . "_gamma_lut_table_R;\n";
	print $fh "\t\t\tpinfo->gamma_lut_table_G = " . lc($name) . "_gamma_lut_table_G;\n";
	print $fh "\t\t\tpinfo->gamma_lut_table_B = " . lc($name) . "_gamma_lut_table_B;\n";
	print $fh "\t\t\tpinfo->gamma_lut_table_len = ARRAY_SIZE(" . lc($name) . "_gamma_lut_table_R);\n";
	print $fh "\t\t\tpinfo->igm_lut_table_R = " . lc($name) . "_igm_lut_table_R;\n";
	print $fh "\t\t\tpinfo->igm_lut_table_G = " . lc($name) . "_igm_lut_table_G;\n";
	print $fh "\t\t\tpinfo->igm_lut_table_B = " . lc($name) . "_igm_lut_table_B;\n";
	print $fh "\t\t\tpinfo->igm_lut_table_len = ARRAY_SIZE(" . lc($name) . "_igm_lut_table_R);\n";
#	print $fh "\t\t\tpinfo->gmp_support = 1;\n";
	print $fh "\t\t\tpinfo->gmp_lut_table_low32bit = &" . lc($name) . "_gmp_lut_table_low32bit[0][0][0];\n";
	print $fh "\t\t\tpinfo->gmp_lut_table_high4bit = &" . lc($name) . "_gmp_lut_table_high4bit[0][0][0];\n";
	print $fh "\t\t\tpinfo->gmp_lut_table_len = ARRAY_SIZE(" . lc($name) . "_gmp_lut_table_low32bit);\n";
#	print $fh "\t\t\tpinfo->xcc_support = 1;\n";
	print $fh "\t\t\tpinfo->xcc_table = " . lc($name) . "_xcc_table;\n";
	print $fh "\t\t\tpinfo->xcc_table_len = ARRAY_SIZE(" . lc($name) . "_xcc_table);\n";
	print $fh "\t\t}\n";
	print $fh "\t\tbreak;\n";
}

sub printlcdeffectmapfunc
{
	my $fh = shift;
	my $map;
	my $default_panel_id = 0;
	my $len = 0;
	
	$default_panel_id = pop(@LCDMap);
	$len = length ($panel_compatibe);
	$len = length ($default_panel_id) - $len - 2;
	$default_panel_id = substr($default_panel_id, 0, $len);
	print $fh "static uint8_t hw_lcd_get_panel_id(char *name)\n";
	print $fh "{\n";
	print $fh "\tuint8_t lcd_panel_id = AUO_OTM1901A_5P2_1080P_VIDEO_DEFAULT_PANEL;" . " /*default panel id*/\n";
	print $fh "\tint i = 0;\n";

	print $fh "\tfor (i = 0; i < ARRAY_SIZE(lcd_map); ++i) {\n";
	print $fh "\t\tif (0 == strncmp(name, lcd_map[i].panel_name, strlen(name)))";
	print $fh "{\t\t\n";
	print $fh "\t\t\tlcd_panel_id = lcd_map[i].lcd_id;\n";
	print $fh "\t\t\tbreak;\n";
	print $fh "\t\t}\n";
	print $fh "\t}\n\n";
	
	print $fh "\treturn lcd_panel_id;\n";
	print $fh "}\n";
}
