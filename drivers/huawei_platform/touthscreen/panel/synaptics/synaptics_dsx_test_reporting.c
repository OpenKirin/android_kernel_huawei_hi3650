/*Add synaptics new driver "Synaptics DSX I2C V2.0"*/
/*
 * Synaptics DSX touchscreen driver
 *
 * Copyright (C) 2012 Synaptics Incorporated
 *
 * Copyright (C) 2012 Alexandra Chin <alexandra.chin@tw.synaptics.com>
 * Copyright (C) 2012 Scott Lin <scott.lin@tw.synaptics.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/slab.h>
#include <linux/i2c.h>
#include <linux/interrupt.h>
#include <linux/delay.h>
#include <linux/input.h>
#include <linux/ctype.h>
#include <linux/hrtimer.h>
#include "synaptics.h"
#include <../../huawei_touchscreen_chips.h>
#include <linux/gpio.h>
#include <linux/regulator/consumer.h>

#define WATCHDOG_HRTIMER
#define WATCHDOG_TIMEOUT_S 2
#define FORCE_TIMEOUT_100MS 10
#define MAX_I2C_MSG_LENS 0x3F
/*#define STATUS_WORK_INTERVAL 20 /* ms */
/*Add synaptics capacitor test function */
#define MMITEST
/*
#define RAW_HEX
#define HUMAN_READABLE
*/
#define F54_MAX_CAP_TITLE_SIZE	50
#define IRQ_ON 1
#define IRQ_OFF 0
#define Interrupt_Enable_Addr  0x0052
#define IRQ_ENA_MASK_BIT 0x04
#define STATUS_IDLE 0
#define STATUS_BUSY 1

#define DATA_REPORT_INDEX_OFFSET 1
#define DATA_REPORT_DATA_OFFSET 3

#define SENSOR_RX_MAPPING_OFFSET 1
#define SENSOR_TX_MAPPING_OFFSET 2

#define COMMAND_GET_REPORT 1
#define COMMAND_FORCE_CAL 2
#define COMMAND_FORCE_UPDATE 4

#define CONTROL_42_SIZE 2
#define CONTROL_43_54_SIZE 13
#define CONTROL_55_56_SIZE 2
#define CONTROL_58_SIZE 1
#define CONTROL_59_SIZE 2
#define CONTROL_60_62_SIZE 3
#define CONTROL_63_SIZE 1
#define CONTROL_64_67_SIZE 4
#define CONTROL_68_73_SIZE 8
#define CONTROL_74_SIZE 2
#define CONTROL_76_SIZE 1
#define CONTROL_77_78_SIZE 2
#define CONTROL_79_83_SIZE 5
#define CONTROL_84_85_SIZE 2
#define CONTROL_86_SIZE 1
#define CONTROL_87_SIZE 1

#define HIGH_RESISTANCE_DATA_SIZE 6
#define FULL_RAW_CAP_MIN_MAX_DATA_SIZE 4
#define TREX_DATA_SIZE 7

#define NO_AUTO_CAL_MASK 0x01

#define concat(a, b) a##b

#define GROUP(_attrs) {\
	.attrs = _attrs,\
}

#define attrify(propname) (&dev_attr_##propname.attr)

#define show_prototype(propname)\
static ssize_t concat(synaptics_rmi4_f54, _##propname##_show)(\
		struct device *dev,\
		struct device_attribute *attr,\
		char *buf);\
\
static struct device_attribute dev_attr_##propname =\
		__ATTR(propname, S_IRUGO,\
		concat(synaptics_rmi4_f54, _##propname##_show),\
		NULL);

#define store_prototype(propname)\
static ssize_t concat(synaptics_rmi4_f54, _##propname##_store)(\
		struct device *dev,\
		struct device_attribute *attr,\
		const char *buf, size_t count);\
\
static struct device_attribute dev_attr_##propname =\
		__ATTR(propname, (S_IWUSR | S_IWGRP),\
		NULL,\
		concat(synaptics_rmi4_f54, _##propname##_store));

#define show_store_prototype(propname)\
static ssize_t concat(synaptics_rmi4_f54, _##propname##_show)(\
		struct device *dev,\
		struct device_attribute *attr,\
		char *buf);\
\
static ssize_t concat(synaptics_rmi4_f54, _##propname##_store)(\
		struct device *dev,\
		struct device_attribute *attr,\
		const char *buf, size_t count);\
\
static struct device_attribute dev_attr_##propname =\
		__ATTR(propname, (S_IRUGO | S_IWUSR | S_IWGRP),\
		concat(synaptics_rmi4_f54, _##propname##_show),\
		concat(synaptics_rmi4_f54, _##propname##_store));

#define simple_show_func(rtype, propname, fmt)\
static ssize_t concat(synaptics_rmi4_f54, _##propname##_show)(\
		struct device *dev,\
		struct device_attribute *attr,\
		char *buf)\
{\
	return snprintf(buf, PAGE_SIZE, fmt, f54->rtype.propname);\
} \

#define simple_show_func_unsigned(rtype, propname)\
simple_show_func(rtype, propname, "%u\n")

#define show_func(rtype, rgrp, propname, fmt)\
static ssize_t concat(synaptics_rmi4_f54, _##propname##_show)(\
		struct device *dev,\
		struct device_attribute *attr,\
		char *buf)\
{\
	int retval;\
	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;\
\
	mutex_lock(&f54->rtype##_mutex);\
\
	retval = f54->fn_ptr->read(rmi4_data,\
			f54->rtype.rgrp->address,\
			f54->rtype.rgrp->data,\
			sizeof(f54->rtype.rgrp->data));\
	mutex_unlock(&f54->rtype##_mutex);\
	if (retval < 0) {\
		dev_err(&rmi4_data->i2c_client->dev,\
				"%s: Failed to read " #rtype\
				" " #rgrp "\n",\
				__func__);\
		return retval;\
	} \
\
	return snprintf(buf, PAGE_SIZE, fmt,\
			f54->rtype.rgrp->propname);\
} \

#define show_store_func(rtype, rgrp, propname, fmt)\
show_func(rtype, rgrp, propname, fmt)\
\
static ssize_t concat(synaptics_rmi4_f54, _##propname##_store)(\
		struct device *dev,\
		struct device_attribute *attr,\
		const char *buf, size_t count)\
{\
	int retval;\
	unsigned long setting;\
	unsigned long o_setting;\
	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;\
\
	retval = sstrtoul(buf, 10, &setting);\
	if (retval)\
		return retval;\
\
	mutex_lock(&f54->rtype##_mutex);\
	retval = f54->fn_ptr->read(rmi4_data,\
			f54->rtype.rgrp->address,\
			f54->rtype.rgrp->data,\
			sizeof(f54->rtype.rgrp->data));\
	if (retval < 0) {\
		mutex_unlock(&f54->rtype##_mutex);\
		dev_err(&rmi4_data->i2c_client->dev,\
				"%s: Failed to read " #rtype\
				" " #rgrp "\n",\
				__func__);\
		return retval;\
	} \
\
	if (f54->rtype.rgrp->propname == setting) {\
		mutex_unlock(&f54->rtype##_mutex);\
		return count;\
	} \
\
	o_setting = f54->rtype.rgrp->propname;\
	f54->rtype.rgrp->propname = setting;\
\
	retval = f54->fn_ptr->write(rmi4_data,\
			f54->rtype.rgrp->address,\
			f54->rtype.rgrp->data,\
			sizeof(f54->rtype.rgrp->data));\
	if (retval < 0) {\
		dev_err(&rmi4_data->i2c_client->dev,\
				"%s: Failed to write " #rtype\
				" " #rgrp "\n",\
				__func__);\
		f54->rtype.rgrp->propname = o_setting;\
		mutex_unlock(&f54->rtype##_mutex);\
		return retval;\
	} \
\
	mutex_unlock(&f54->rtype##_mutex);\
	return count;\
} \

#define show_store_func_unsigned(rtype, rgrp, propname)\
show_store_func(rtype, rgrp, propname, "%u\n")

#define show_replicated_func(rtype, rgrp, propname, fmt)\
static ssize_t concat(synaptics_rmi4_f54, _##propname##_show)(\
		struct device *dev,\
		struct device_attribute *attr,\
		char *buf)\
{\
	int retval;\
	int size = 0;\
	unsigned char ii;\
	unsigned char length;\
	unsigned char *temp;\
	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;\
\
	mutex_lock(&f54->rtype##_mutex);\
\
	length = f54->rtype.rgrp->length;\
\
	retval = f54->fn_ptr->read(rmi4_data,\
			f54->rtype.rgrp->address,\
			(unsigned char *)f54->rtype.rgrp->data,\
			length);\
	mutex_unlock(&f54->rtype##_mutex);\
	if (retval < 0) {\
		dev_dbg(&rmi4_data->i2c_client->dev,\
				"%s: Failed to read " #rtype\
				" " #rgrp "\n",\
				__func__);\
	} \
\
	temp = buf;\
\
	for (ii = 0; ii < length; ii++) {\
		retval = snprintf(temp, PAGE_SIZE - size, fmt " ",\
				f54->rtype.rgrp->data[ii].propname);\
		if (retval < 0) {\
			dev_err(&rmi4_data->i2c_client->dev,\
					"%s: Faild to write output\n",\
					__func__);\
			return retval;\
		} \
		size += retval;\
		temp += retval;\
	} \
\
	retval = snprintf(temp, PAGE_SIZE - size, "\n");\
	if (retval < 0) {\
		dev_err(&rmi4_data->i2c_client->dev,\
				"%s: Faild to write null terminator\n",\
				__func__);\
		return retval;\
	} \
\
	return size + retval;\
} \

#define show_replicated_func_unsigned(rtype, rgrp, propname)\
show_replicated_func(rtype, rgrp, propname, "%u")

#define show_store_replicated_func(rtype, rgrp, propname, fmt)\
show_replicated_func(rtype, rgrp, propname, fmt)\
\
static ssize_t concat(synaptics_rmi4_f54, _##propname##_store)(\
		struct device *dev,\
		struct device_attribute *attr,\
		const char *buf, size_t count)\
{\
	int retval;\
	unsigned int setting;\
	unsigned char ii;\
	unsigned char length;\
	const unsigned char *temp;\
	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;\
\
	mutex_lock(&f54->rtype##_mutex);\
\
	length = f54->rtype.rgrp->length;\
\
	retval = f54->fn_ptr->read(rmi4_data,\
			f54->rtype.rgrp->address,\
			(unsigned char *)f54->rtype.rgrp->data,\
			length);\
	if (retval < 0) {\
		dev_dbg(&rmi4_data->i2c_client->dev,\
				"%s: Failed to read " #rtype\
				" " #rgrp "\n",\
				__func__);\
	} \
\
	temp = buf;\
\
	for (ii = 0; ii < length; ii++) {\
		if (sscanf(temp, fmt, &setting) == 1) {\
			f54->rtype.rgrp->data[ii].propname = setting;\
		} else {\
			retval = f54->fn_ptr->read(rmi4_data,\
					f54->rtype.rgrp->address,\
					(unsigned char *)f54->rtype.rgrp->data,\
					length);\
			mutex_unlock(&f54->rtype##_mutex);\
			return -EINVAL;\
		} \
\
		while (*temp != 0) {\
			temp++;\
			if (isspace(*(temp - 1)) && !isspace(*temp))\
				break;\
		} \
	} \
\
	retval = f54->fn_ptr->write(rmi4_data,\
			f54->rtype.rgrp->address,\
			(unsigned char *)f54->rtype.rgrp->data,\
			length);\
	mutex_unlock(&f54->rtype##_mutex);\
	if (retval < 0) {\
		dev_err(&rmi4_data->i2c_client->dev,\
				"%s: Failed to write " #rtype\
				" " #rgrp "\n",\
				__func__);\
		return retval;\
	} \
\
	return count;\
} \

#define show_store_replicated_func_unsigned(rtype, rgrp, propname)\
show_store_replicated_func(rtype, rgrp, propname, "%u")

enum f54_report_types {
	F54_8BIT_IMAGE = 1,
	F54_16BIT_IMAGE = 2,
	F54_RAW_16BIT_IMAGE = 3,
	F54_HIGH_RESISTANCE = 4,
	F54_TX_TO_TX_SHORT = 5,
	F54_RX_TO_RX1 = 7,
	F54_TRUE_BASELINE = 9,
	F54_FULL_RAW_CAP_MIN_MAX = 13,
	F54_RX_OPENS1 = 14,
	F54_TX_OPEN = 15,
	F54_TX_TO_GROUND = 16,
	F54_RX_TO_RX2 = 17,
	F54_RX_OPENS2 = 18,
	F54_FULL_RAW_CAP = 19,
	F54_FULL_RAW_CAP_RX_COUPLING_COMP = 20,
	F54_SENSOR_SPEED = 22,
	F54_ADC_RANGE = 23,
	F54_TREX_OPENS = 24,
	F54_TREX_TO_GND = 25,
	F54_TREX_SHORTS = 26,
	INVALID_REPORT_TYPE = -1,
};

/*Add synaptics capacitor test function */
#ifdef MMITEST
/*#define CFG_F54_TXCOUNT       14*/
/*#define CFG_F54_RXCOUNT       25*/
#define TOUCH_RX_DEFAULT 26
#define TOUCH_TX_DEFAULT 14
#define TP_TEST_FAILED_REASON_LEN 20

static unsigned char rx = TOUCH_RX_DEFAULT;
static unsigned char tx = TOUCH_TX_DEFAULT;

static bool sysfs_is_busy;
/*modified cap test limit for G630-T00*/

extern struct ts_data g_ts_data;


static short FullRawMaxCap_oflim = 3600;	/*3854;*/
static short FullRawMaxCap_lensone = 3600;
static short FullRawMaxCap_oflim_g760s = 5000;
static short FullRawMaxCap_lensone_g760s = 4900;
static short FullRawMaxCap_GIS = 4000;
static short FullRawMaxCap_YASSY = 4500;

static short FullRawMinCap_oflim = 1450;	/*0;*/
static short FullRawMinCap_lensone = 1450;
static short FullRawMinCap_oflim_g760s = 1700;
static short FullRawMinCap_lensone_g760s = 1700;
static short FullRawMinCap_GIS = 1200;
static short FullRawMinCap_YASSY = 1200;

static short FullRawCapUpperLimit_oflim[TOUCH_TX_DEFAULT * TOUCH_RX_DEFAULT] = {
	3508, 3543, 3548, 3526, 3525, 3523, 3504, 3493, 3482, 3467, 3454, 3441,
	    3421, 3119, 3096, 3110, 3065, 3082, 3044, 3063, 3024, 3042, 3005,
	    3026, 2916, 2808,
	3396, 3431, 3416, 3403, 3387, 3377, 3364, 3352, 3340, 3325, 3314, 3302,
	    3279, 3136, 3110, 3126, 3085, 3100, 3066, 3086, 3048, 3067, 3031,
	    3053, 2944, 2835,
	3386, 3419, 3404, 3389, 3373, 3359, 3345, 3330, 3316, 3299, 3288, 3272,
	    3249, 3137, 3116, 3129, 3088, 3101, 3069, 3092, 3053, 3073, 3037,
	    3059, 2952, 2842,
	3383, 3414, 3400, 3384, 3365, 3350, 3335, 3319, 3305, 3284, 3273, 3258,
	    3236, 3147, 3127, 3142, 3101, 3113, 3080, 3106, 3066, 3086, 3052,
	    3073, 2966, 2853,
	3369, 3401, 3383, 3368, 3349, 3334, 3316, 3304, 3285, 3266, 3252, 3237,
	    3214, 3152, 3134, 3146, 3109, 3119, 3088, 3111, 3072, 3092, 3060,
	    3081, 2975, 2844,
	3359, 3392, 3372, 3359, 3339, 3322, 3303, 3288, 3272, 3252, 3239, 3222,
	    3196, 3164, 3145, 3160, 3122, 3134, 3101, 3124, 3089, 3106, 3075,
	    3095, 2990, 2856,
	3355, 3389, 3369, 3355, 3334, 3318, 3298, 3283, 3267, 3243, 3233, 3214,
	    3186, 3183, 3161, 3178, 3143, 3154, 3123, 3145, 3111, 3129, 3098,
	    3117, 3014, 2875,
	3348, 3378, 3361, 3345, 3325, 3308, 3290, 3272, 3254, 3230, 3219, 3203,
	    3174, 3199, 3180, 3194, 3159, 3172, 3138, 3162, 3130, 3148, 3116,
	    3140, 3033, 2896,
	3335, 3367, 3348, 3331, 3312, 3297, 3276, 3258, 3242, 3215, 3205, 3191,
	    3158, 3213, 3196, 3209, 3175, 3191, 3156, 3182, 3149, 3169, 3138,
	    3161, 3052, 2912,
	3335, 3367, 3347, 3330, 3308, 3294, 3273, 3257, 3239, 3214, 3204, 3187,
	    3157, 3239, 3223, 3237, 3203, 3220, 3188, 3210, 3178, 3200, 3171,
	    3193, 3085, 2942,
	3326, 3357, 3338, 3322, 3301, 3287, 3266, 3249, 3231, 3208, 3196, 3180,
	    3147, 3259, 3244, 3258, 3229, 3244, 3215, 3234, 3205, 3227, 3201,
	    3222, 3112, 2990,
	3323, 3350, 3334, 3317, 3296, 3281, 3262, 3245, 3225, 3205, 3193, 3177,
	    3143, 3284, 3269, 3286, 3258, 3272, 3245, 3262, 3239, 3256, 3232,
	    3252, 3142, 3021,
	3324, 3355, 3335, 3316, 3298, 3283, 3264, 3247, 3229, 3207, 3194, 3179,
	    3146, 3321, 3309, 3327, 3300, 3317, 3294, 3309, 3286, 3307, 3279,
	    3298, 3190, 3075,
	3318, 3338, 3320, 3301, 3280, 3265, 3244, 3228, 3206, 3182, 3168, 3154,
	    3116, 3562, 3530, 3542, 3492, 3511, 3490, 3486, 3466, 3481, 3448,
	    3463, 3351, 3239
};

static short FullRawCapUpperLimit_lensone[TOUCH_TX_DEFAULT * TOUCH_RX_DEFAULT] = {
	3508, 3543, 3548, 3526, 3525, 3523, 3504, 3493, 3482, 3467, 3454, 3441,
	    3421, 3119, 3096, 3110, 3065, 3082, 3044, 3063, 3024, 3042, 3005,
	    3026, 2916, 2808,
	3396, 3431, 3416, 3403, 3387, 3377, 3364, 3352, 3340, 3325, 3314, 3302,
	    3279, 3136, 3110, 3126, 3085, 3100, 3066, 3086, 3048, 3067, 3031,
	    3053, 2944, 2835,
	3386, 3419, 3404, 3389, 3373, 3359, 3345, 3330, 3316, 3299, 3288, 3272,
	    3249, 3137, 3116, 3129, 3088, 3101, 3069, 3092, 3053, 3073, 3037,
	    3059, 2952, 2842,
	3383, 3414, 3400, 3384, 3365, 3350, 3335, 3319, 3305, 3284, 3273, 3258,
	    3236, 3147, 3127, 3142, 3101, 3113, 3080, 3106, 3066, 3086, 3052,
	    3073, 2966, 2853,
	3369, 3401, 3383, 3368, 3349, 3334, 3316, 3304, 3285, 3266, 3252, 3237,
	    3214, 3152, 3134, 3146, 3109, 3119, 3088, 3111, 3072, 3092, 3060,
	    3081, 2975, 2844,
	3359, 3392, 3372, 3359, 3339, 3322, 3303, 3288, 3272, 3252, 3239, 3222,
	    3196, 3164, 3145, 3160, 3122, 3134, 3101, 3124, 3089, 3106, 3075,
	    3095, 2990, 2856,
	3355, 3389, 3369, 3355, 3334, 3318, 3298, 3283, 3267, 3243, 3233, 3214,
	    3186, 3183, 3161, 3178, 3143, 3154, 3123, 3145, 3111, 3129, 3098,
	    3117, 3014, 2875,
	3348, 3378, 3361, 3345, 3325, 3308, 3290, 3272, 3254, 3230, 3219, 3203,
	    3174, 3199, 3180, 3194, 3159, 3172, 3138, 3162, 3130, 3148, 3116,
	    3140, 3033, 2896,
	3335, 3367, 3348, 3331, 3312, 3297, 3276, 3258, 3242, 3215, 3205, 3191,
	    3158, 3213, 3196, 3209, 3175, 3191, 3156, 3182, 3149, 3169, 3138,
	    3161, 3052, 2912,
	3335, 3367, 3347, 3330, 3308, 3294, 3273, 3257, 3239, 3214, 3204, 3187,
	    3157, 3239, 3223, 3237, 3203, 3220, 3188, 3210, 3178, 3200, 3171,
	    3193, 3085, 2942,
	3326, 3357, 3338, 3322, 3301, 3287, 3266, 3249, 3231, 3208, 3196, 3180,
	    3147, 3259, 3244, 3258, 3229, 3244, 3215, 3234, 3205, 3227, 3201,
	    3222, 3112, 2990,
	3323, 3350, 3334, 3317, 3296, 3281, 3262, 3245, 3225, 3205, 3193, 3177,
	    3143, 3284, 3269, 3286, 3258, 3272, 3245, 3262, 3239, 3256, 3232,
	    3252, 3142, 3021,
	3324, 3355, 3335, 3316, 3298, 3283, 3264, 3247, 3229, 3207, 3194, 3179,
	    3146, 3321, 3309, 3327, 3300, 3317, 3294, 3309, 3286, 3307, 3279,
	    3298, 3190, 3075,
	3318, 3338, 3320, 3301, 3280, 3265, 3244, 3228, 3206, 3182, 3168, 3154,
	    3116, 3562, 3530, 3542, 3492, 3511, 3490, 3486, 3466, 3481, 3448,
	    3463, 3351, 3239
};

static short FullRawCapUpperLimit_oflim_g760s[TOUCH_TX_DEFAULT *
					      TOUCH_RX_DEFAULT] = {
	3580, 3724, 3725, 3728, 3770, 3796, 3784, 3824, 3840, 3872, 3905, 3926,
	    3965, 4537, 4550, 4587, 4639, 4678, 4729, 4784, 4846, 4937, 4960,
	    4985, 4826,
	3611, 3758, 3760, 3759, 3797, 3824, 3810, 3845, 3867, 3894, 3932, 3962,
	    4205, 4344, 4369, 4405, 4452, 4494, 4537, 4576, 4643, 4712, 4781,
	    4820, 4633,
	3633, 3780, 3779, 3784, 3819, 3844, 3829, 3868, 3883, 3911, 3945, 3972,
	    4002, 4293, 4319, 4357, 4410, 4447, 4486, 4540, 4608, 4664, 4725,
	    4774, 4603,
	3667, 3810, 3814, 3811, 3848, 3879, 3862, 3898, 3913, 3940, 3971, 3987,
	    4023, 4248, 4283, 4323, 4371, 4413, 4459, 4511, 4574, 4634, 4694,
	    4734, 4574,
	3666, 3818, 3810, 3815, 3849, 3884, 3868, 3906, 3916, 3942, 3971, 4001,
	    4030, 4204, 4232, 4275, 4329, 4374, 4420, 4474, 4542, 4603, 4660,
	    4708, 4546,
	3693, 3841, 3844, 3848, 3884, 3907, 3897, 3931, 3941, 3967, 4002, 4030,
	    4062, 4171, 4202, 4245, 4299, 4347, 4388, 4448, 4511, 4573, 4625,
	    4683, 4531,
	3729, 3884, 3884, 3887, 3919, 3941, 3926, 3961, 3976, 4006, 4030, 4049,
	    4093, 4130, 4170, 4219, 4262, 4313, 4356, 4418, 4483, 4551, 4607,
	    4663, 4508,
	3781, 3939, 3937, 3939, 3968, 3992, 3978, 4009, 4027, 4054, 4080, 4097,
	    4139, 4114, 4160, 4206, 4247, 4296, 4340, 4403, 4460, 4524, 4589,
	    4641, 4496,
	3799, 3952, 3950, 3952, 3981, 4005, 4001, 4027, 4059, 4075, 4111, 4130,
	    4154, 4097, 4130, 4171, 4225, 4279, 4325, 4387, 4444, 4491, 4561,
	    4622, 4490,
	3867, 4026, 4024, 4027, 4049, 4072, 4062, 4096, 4105, 4128, 4157, 4174,
	    4217, 4080, 4115, 4162, 4209, 4264, 4308, 4378, 4439, 4481, 4548,
	    4609, 4478,
	3924, 4084, 4084, 4085, 4110, 4132, 4122, 4154, 4169, 4188, 4213, 4223,
	    4270, 4067, 4101, 4149, 4204, 4253, 4303, 4374, 4439, 4474, 4538,
	    4592, 4464,
	3967, 4128, 4130, 4132, 4157, 4178, 4173, 4200, 4217, 4230, 4254, 4271,
	    4309, 4059, 4101, 4143, 4199, 4261, 4304, 4366, 4431, 4474, 4542,
	    4591, 4461,
	4044, 4213, 4218, 4215, 4238, 4254, 4251, 4271, 4286, 4300, 4322, 4334,
	    4382, 4050, 4091, 4136, 4188, 4244, 4287, 4356, 4420, 4459, 4531,
	    4583, 4456,
	4290, 4453, 4457, 4452, 4478, 4499, 4496, 4531, 4550, 4596, 4628, 4678,
	    4891, 4014, 4054, 4100, 4157, 4215, 4262, 4334, 4401, 4439, 4508,
	    4576, 4440
};

static short FullRawCapUpperLimit_lensone_760s[TOUCH_TX_DEFAULT *
					       TOUCH_RX_DEFAULT] = {
	3525, 3705, 3693, 3727, 3706, 3731, 3759, 3746, 3789, 3820, 3854, 3880,
	    3872, 4422, 4466, 4504, 4537, 4579, 4612, 4664, 4709, 4772, 4782,
	    4823, 4699,
	3562, 3723, 3711, 3737, 3708, 3731, 3760, 3767, 3794, 3845, 3875, 3898,
	    3900, 4204, 4258, 4293, 4329, 4365, 4407, 4462, 4509, 4553, 4598,
	    4639, 4512,
	3568, 3727, 3703, 3724, 3698, 3719, 3746, 3760, 3790, 3845, 3879, 3903,
	    3906, 4170, 4196, 4230, 4279, 4309, 4358, 4413, 4466, 4511, 4553,
	    4600, 4460,
	3567, 3732, 3706, 3723, 3708, 3729, 3749, 3757, 3792, 3835, 3868, 3890,
	    3903, 4101, 4152, 4183, 4223, 4257, 4304, 4355, 4405, 4453, 4491,
	    4538, 4439,
	3602, 3767, 3715, 3750, 3733, 3759, 3784, 3786, 3814, 3854, 3888, 3910,
	    3915, 4070, 4117, 4158, 4188, 4235, 4277, 4334, 4377, 4435, 4479,
	    4522, 4420,
	3632, 3802, 3744, 3790, 3771, 3809, 3825, 3816, 3850, 3881, 3900, 3910,
	    3919, 4035, 4093, 4143, 4179, 4225, 4257, 4306, 4344, 4387, 4434,
	    4481, 4379,
	3673, 3837, 3777, 3819, 3802, 3822, 3831, 3845, 3887, 3894, 3907, 3946,
	    3949, 3996, 4059, 4119, 4150, 4193, 4225, 4275, 4304, 4349, 4392,
	    4448, 4338,
	3724, 3849, 3809, 3842, 3832, 3850, 3871, 3879, 3918, 3929, 3953, 3983,
	    3987, 3965, 4006, 4070, 4123, 4184, 4222, 4265, 4305, 4344, 4397,
	    4451, 4353,
	3760, 3885, 3837, 3874, 3855, 3883, 3881, 3910, 3955, 3968, 3993, 4022,
	    4019, 3944, 4006, 4067, 4111, 4165, 4205, 4247, 4287, 4342, 4409,
	    4457, 4369,
	3799, 3915, 3870, 3892, 3890, 3901, 3919, 3949, 3976, 3991, 4015, 4039,
	    4046, 3916, 3972, 4036, 4076, 4128, 4166, 4222, 4264, 4323, 4401,
	    4452, 4358,
	3833, 3970, 3922, 3954, 3949, 3972, 3983, 3994, 4043, 4052, 4076, 4104,
	    4104, 3923, 3975, 4026, 4058, 4109, 4163, 4200, 4244, 4308, 4386,
	    4436, 4340,
	3898, 4011, 3984, 4010, 3994, 4014, 4024, 4054, 4083, 4098, 4119, 4140,
	    4156, 3914, 3962, 4023, 4049, 4096, 4132, 4192, 4240, 4278, 4340,
	    4407, 4304,
	3959, 4079, 4074, 4091, 4083, 4104, 4098, 4140, 4144, 4153, 4170, 4192,
	    4218, 3903, 3970, 4011, 4045, 4101, 4140, 4195, 4245, 4286, 4339,
	    4396, 4296,
	4195, 4351, 4318, 4340, 4332, 4345, 4387, 4408, 4438, 4470, 4490, 4524,
	    4660, 3894, 3957, 4013, 4058, 4106, 4153, 4212, 4274, 4338, 4410,
	    4456, 4348
};

static short FullRawCapUpperLimit_GIS[TOUCH_TX_DEFAULT * TOUCH_RX_DEFAULT] = {
	3072, 3101, 3099, 3087, 3085, 3085, 3065, 3064, 3051, 3044, 3036, 3032,
	    3114, 2716, 2718, 2708, 2696, 2688, 2700, 2682, 2682, 2671, 2668,
	    2654, 2650, 2522,
	3168, 3193, 3185, 3168, 3161, 3158, 3133, 3129, 3113, 3103, 3091, 3085,
	    3058, 2915, 2917, 2906, 2895, 2888, 2903, 2885, 2885, 2875, 2873,
	    2858, 2855, 2756,
	3161, 3185, 3175, 3157, 3149, 3144, 3118, 3115, 3095, 3085, 3072, 3063,
	    3026, 2915, 2915, 2904, 2892, 2887, 2900, 2883, 2883, 2873, 2871,
	    2856, 2858, 2975,
	3151, 3177, 3166, 3147, 3137, 3132, 3105, 3100, 3080, 3068, 3055, 3048,
	    3006, 2921, 2920, 2910, 2900, 2893, 2908, 2890, 2891, 2880, 2877,
	    2864, 2862, 2804,
	3136, 3166, 3154, 3135, 3126, 3120, 3093, 3087, 3066, 3055, 3041, 3035,
	    2990, 2929, 2927, 2917, 2909, 2902, 2917, 2900, 2900, 2890, 2887,
	    2872, 2870, 2742,
	3130, 3159, 3148, 3129, 3119, 3113, 3085, 3079, 3057, 3045, 3032, 3024,
	    2977, 2941, 2939, 2929, 2920, 2914, 2929, 2911, 2911, 2901, 2898,
	    2885, 2882, 2765,
	3124, 3152, 3139, 3120, 3109, 3103, 3074, 3068, 3046, 3034, 3020, 3012,
	    2963, 2954, 2950, 2940, 2930, 2925, 2940, 2922, 2922, 2911, 2908,
	    2895, 2897, 2971,
	3117, 3144, 3131, 3111, 3100, 3095, 3065, 3059, 3036, 3025, 3011, 3003,
	    2953, 2973, 2967, 2957, 2947, 2941, 2956, 2938, 2938, 2927, 2926,
	    2910, 2913, 2974,
	3112, 3138, 3126, 3106, 3094, 3089, 3061, 3053, 3031, 3020, 3006, 2999,
	    2947, 2991, 2983, 2974, 2966, 2959, 2975, 2959, 2959, 2949, 2947,
	    2933, 2933, 2828,
	3109, 3136, 3123, 3103, 3091, 3085, 3057, 3050, 3029, 3018, 3003, 2995,
	    2942, 3013, 3004, 2996, 2986, 2980, 2996, 2979, 2979, 2970, 2969,
	    2956, 2957, 2852,
	3106, 3133, 3120, 3099, 3088, 3081, 3052, 3046, 3024, 3014, 2998, 2990,
	    2938, 3035, 3023, 3016, 3007, 3000, 3016, 3000, 3000, 2991, 2990,
	    2980, 2982, 2943,
	3103, 3131, 3117, 3097, 3085, 3079, 3050, 3045, 3021, 3011, 2996, 2989,
	    2935, 3056, 3044, 3036, 3028, 3021, 3036, 3020, 3021, 3013, 3016,
	    3005, 3012, 3198,
	3099, 3127, 3115, 3095, 3085, 3079, 3052, 3046, 3024, 3014, 3000, 2993,
	    2939, 3099, 3078, 3071, 3064, 3056, 3073, 3059, 3060, 3054, 3057,
	    3047, 3049, 3004,
	2921, 2939, 2926, 2905, 2894, 2886, 2858, 2850, 2827, 2817, 2802, 2794,
	    2740, 3510, 3167, 3138, 3116, 3101, 3110, 3091, 3088, 3080, 3079,
	    3069, 3072, 3169
};

static short FullRawCapUpperLimit_YASSY[TOUCH_TX_DEFAULT * TOUCH_RX_DEFAULT] = {
	3035, 3317, 3308, 3308, 3298, 3288, 3281, 3272, 3262, 3256, 3250, 3239,
	    3324, 2841, 2840, 2829, 2821, 2814, 2798, 2801, 2786, 2791, 2778,
	    2771, 2707, 2544,
	3307, 3604, 3587, 3584, 3571, 3558, 3546, 3534, 3521, 3512, 3504, 3489,
	    3480, 3241, 3246, 3238, 3231, 3226, 3213, 3217, 3202, 3209, 3197,
	    3189, 3120, 2929,
	3292, 3591, 3571, 3564, 3550, 3536, 3525, 3510, 3494, 3484, 3472, 3457,
	    3440, 3244, 3248, 3239, 3235, 3230, 3215, 3220, 3203, 3210, 3199,
	    3192, 3123, 3001,
	3286, 3581, 3560, 3552, 3535, 3520, 3509, 3490, 3475, 3461, 3451, 3434,
	    3414, 3252, 3255, 3247, 3246, 3240, 3225, 3230, 3214, 3219, 3211,
	    3203, 3132, 2972,
	3278, 3570, 3550, 3540, 3522, 3504, 3491, 3474, 3457, 3446, 3432, 3416,
	    3397, 3268, 3269, 3261, 3260, 3253, 3238, 3246, 3229, 3233, 3224,
	    3216, 3143, 2951,
	3269, 3561, 3537, 3528, 3505, 3488, 3474, 3456, 3440, 3426, 3413, 3395,
	    3376, 3281, 3283, 3274, 3273, 3267, 3258, 3260, 3244, 3248, 3241,
	    3232, 3156, 2964,
	3261, 3551, 3527, 3517, 3494, 3476, 3462, 3444, 3428, 3414, 3399, 3383,
	    3358, 3297, 3298, 3291, 3288, 3283, 3276, 3275, 3259, 3264, 3257,
	    3248, 3171, 3049,
	3251, 3540, 3515, 3506, 3487, 3466, 3449, 3432, 3415, 3400, 3388, 3370,
	    3345, 3317, 3320, 3313, 3310, 3305, 3299, 3298, 3282, 3286, 3281,
	    3273, 3197, 3093,
	3245, 3532, 3508, 3501, 3478, 3455, 3441, 3423, 3402, 3387, 3375, 3357,
	    3329, 3338, 3339, 3334, 3330, 3329, 3322, 3322, 3305, 3311, 3304,
	    3298, 3220, 3034,
	3246, 3531, 3508, 3498, 3475, 3453, 3441, 3421, 3399, 3383, 3371, 3352,
	    3324, 3365, 3367, 3364, 3359, 3357, 3351, 3350, 3335, 3342, 3333,
	    3328, 3251, 3060,
	3243, 3528, 3507, 3492, 3472, 3448, 3434, 3414, 3393, 3378, 3368, 3348,
	    3319, 3397, 3400, 3396, 3394, 3392, 3386, 3385, 3370, 3377, 3369,
	    3363, 3286, 3134,
	3237, 3525, 3500, 3487, 3467, 3445, 3427, 3408, 3387, 3373, 3361, 3340,
	    3311, 3426, 3428, 3424, 3423, 3422, 3416, 3416, 3403, 3409, 3401,
	    3396, 3321, 3278,
	3237, 3522, 3500, 3489, 3466, 3444, 3428, 3408, 3388, 3374, 3362, 3343,
	    3315, 3474, 3471, 3470, 3470, 3471, 3466, 3465, 3454, 3460, 3452,
	    3448, 3369, 3194,
	2907, 3163, 3138, 3125, 3099, 3076, 3057, 3034, 3014, 2999, 2985, 2964,
	    2936, 3355, 3242, 3234, 3230, 3226, 3219, 3216, 3202, 3205, 3198,
	    3192, 3120, 3033
};

static short FullRawCapLowerLimit_oflim[TOUCH_TX_DEFAULT * TOUCH_RX_DEFAULT] = {
	1889, 1908, 1910, 1899, 1898, 1897, 1887, 1881, 1875, 1867, 1860, 1853,
	    1842, 1680, 1668, 1675, 1651, 1660, 1639, 1649, 1628, 1638, 1618,
	    1630, 1570, 1512,
	1829, 1847, 1840, 1833, 1824, 1818, 1812, 1805, 1798, 1791, 1784, 1778,
	    1766, 1688, 1675, 1684, 1661, 1669, 1651, 1661, 1642, 1651, 1632,
	    1644, 1585, 1527,
	1823, 1841, 1833, 1825, 1816, 1808, 1801, 1793, 1786, 1776, 1770, 1762,
	    1750, 1689, 1678, 1685, 1663, 1670, 1653, 1665, 1644, 1654, 1635,
	    1647, 1589, 1530,
	1821, 1838, 1830, 1822, 1812, 1804, 1795, 1787, 1779, 1768, 1762, 1754,
	    1742, 1694, 1684, 1692, 1670, 1676, 1658, 1672, 1651, 1662, 1643,
	    1655, 1597, 1536,
	1814, 1831, 1822, 1814, 1803, 1795, 1786, 1779, 1769, 1758, 1751, 1743,
	    1730, 1697, 1687, 1694, 1674, 1679, 1663, 1675, 1654, 1665, 1648,
	    1659, 1602, 1531,
	1809, 1826, 1816, 1809, 1798, 1789, 1778, 1771, 1762, 1751, 1744, 1735,
	    1721, 1704, 1693, 1701, 1681, 1687, 1670, 1682, 1663, 1673, 1656,
	    1667, 1610, 1538,
	1807, 1825, 1814, 1807, 1795, 1787, 1776, 1767, 1759, 1746, 1741, 1730,
	    1716, 1714, 1702, 1711, 1692, 1698, 1682, 1694, 1675, 1685, 1668,
	    1679, 1623, 1548,
	1803, 1819, 1810, 1801, 1790, 1781, 1772, 1762, 1752, 1739, 1733, 1725,
	    1709, 1723, 1712, 1720, 1701, 1708, 1689, 1703, 1685, 1695, 1678,
	    1691, 1633, 1560,
	1796, 1813, 1803, 1794, 1784, 1775, 1764, 1754, 1746, 1731, 1726, 1718,
	    1701, 1730, 1721, 1728, 1710, 1718, 1699, 1714, 1696, 1706, 1690,
	    1702, 1643, 1568,
	1796, 1813, 1802, 1793, 1782, 1774, 1762, 1754, 1744, 1731, 1725, 1716,
	    1700, 1744, 1735, 1743, 1725, 1734, 1716, 1728, 1711, 1723, 1707,
	    1719, 1661, 1584,
	1791, 1807, 1797, 1788, 1777, 1769, 1758, 1749, 1739, 1727, 1721, 1712,
	    1694, 1755, 1746, 1754, 1739, 1747, 1731, 1741, 1725, 1737, 1723,
	    1735, 1675, 1610,
	1789, 1804, 1795, 1786, 1775, 1766, 1756, 1747, 1736, 1725, 1719, 1710,
	    1692, 1768, 1760, 1769, 1754, 1762, 1747, 1756, 1744, 1753, 1740,
	    1751, 1692, 1626,
	1789, 1806, 1796, 1785, 1775, 1767, 1757, 1748, 1738, 1727, 1720, 1712,
	    1694, 1788, 1781, 1791, 1777, 1786, 1773, 1782, 1769, 1780, 1765,
	    1776, 1718, 1655,
	1786, 1797, 1787, 1777, 1766, 1758, 1747, 1738, 1726, 1713, 1706, 1698,
	    1678, 1918, 1901, 1907, 1880, 1890, 1879, 1877, 1866, 1874, 1856,
	    1865, 1804, 1744
};

static short FullRawCapLowerLimit_lensone[TOUCH_TX_DEFAULT * TOUCH_RX_DEFAULT] = {
	1889, 1908, 1910, 1899, 1898, 1897, 1887, 1881, 1875, 1867, 1860, 1853,
	    1842, 1680, 1668, 1675, 1651, 1660, 1639, 1649, 1628, 1638, 1618,
	    1630, 1570, 1512,
	1829, 1847, 1840, 1833, 1824, 1818, 1812, 1805, 1798, 1791, 1784, 1778,
	    1766, 1688, 1675, 1684, 1661, 1669, 1651, 1661, 1642, 1651, 1632,
	    1644, 1585, 1527,
	1823, 1841, 1833, 1825, 1816, 1808, 1801, 1793, 1786, 1776, 1770, 1762,
	    1750, 1689, 1678, 1685, 1663, 1670, 1653, 1665, 1644, 1654, 1635,
	    1647, 1589, 1530,
	1821, 1838, 1830, 1822, 1812, 1804, 1795, 1787, 1779, 1768, 1762, 1754,
	    1742, 1694, 1684, 1692, 1670, 1676, 1658, 1672, 1651, 1662, 1643,
	    1655, 1597, 1536,
	1814, 1831, 1822, 1814, 1803, 1795, 1786, 1779, 1769, 1758, 1751, 1743,
	    1730, 1697, 1687, 1694, 1674, 1679, 1663, 1675, 1654, 1665, 1648,
	    1659, 1602, 1531,
	1809, 1826, 1816, 1809, 1798, 1789, 1778, 1771, 1762, 1751, 1744, 1735,
	    1721, 1704, 1693, 1701, 1681, 1687, 1670, 1682, 1663, 1673, 1656,
	    1667, 1610, 1538,
	1807, 1825, 1814, 1807, 1795, 1787, 1776, 1767, 1759, 1746, 1741, 1730,
	    1716, 1714, 1702, 1711, 1692, 1698, 1682, 1694, 1675, 1685, 1668,
	    1679, 1623, 1548,
	1803, 1819, 1810, 1801, 1790, 1781, 1772, 1762, 1752, 1739, 1733, 1725,
	    1709, 1723, 1712, 1720, 1701, 1708, 1689, 1703, 1685, 1695, 1678,
	    1691, 1633, 1560,
	1796, 1813, 1803, 1794, 1784, 1775, 1764, 1754, 1746, 1731, 1726, 1718,
	    1701, 1730, 1721, 1728, 1710, 1718, 1699, 1714, 1696, 1706, 1690,
	    1702, 1643, 1568,
	1796, 1813, 1802, 1793, 1782, 1774, 1762, 1754, 1744, 1731, 1725, 1716,
	    1700, 1744, 1735, 1743, 1725, 1734, 1716, 1728, 1711, 1723, 1707,
	    1719, 1661, 1584,
	1791, 1807, 1797, 1788, 1777, 1769, 1758, 1749, 1739, 1727, 1721, 1712,
	    1694, 1755, 1746, 1754, 1739, 1747, 1731, 1741, 1725, 1737, 1723,
	    1735, 1675, 1610,
	1789, 1804, 1795, 1786, 1775, 1766, 1756, 1747, 1736, 1725, 1719, 1710,
	    1692, 1768, 1760, 1769, 1754, 1762, 1747, 1756, 1744, 1753, 1740,
	    1751, 1692, 1626,
	1789, 1806, 1796, 1785, 1775, 1767, 1757, 1748, 1738, 1727, 1720, 1712,
	    1694, 1788, 1781, 1791, 1777, 1786, 1773, 1782, 1769, 1780, 1765,
	    1776, 1718, 1655,
	1786, 1797, 1787, 1777, 1766, 1758, 1747, 1738, 1726, 1713, 1706, 1698,
	    1678, 1918, 1901, 1907, 1880, 1890, 1879, 1877, 1866, 1874, 1856,
	    1865, 1804, 1744
};

static short FullRawCapLowerLimit_oflim_g760s[TOUCH_TX_DEFAULT *
					      TOUCH_RX_DEFAULT] = {
	1620, 1802, 1797, 1802, 1809, 1814, 1834, 1838, 1852, 1866, 1894, 1911,
	    1921, 2257, 2282, 2288, 2323, 2334, 2372, 2385, 2420, 2449, 2425,
	    2450, 2347,
	1733, 1840, 1845, 1844, 1860, 1856, 1876, 1879, 1907, 1926, 1935, 1952,
	    1965, 2170, 2190, 2205, 2239, 2250, 2288, 2303, 2336, 2361, 2387,
	    2409, 2250,
	1738, 1848, 1848, 1853, 1863, 1859, 1882, 1882, 1908, 1929, 1935, 1958,
	    1971, 2141, 2159, 2178, 2208, 2225, 2253, 2275, 2305, 2338, 2362,
	    2387, 2243,
	1746, 1848, 1854, 1852, 1864, 1867, 1884, 1888, 1911, 1904, 1852, 1945,
	    1977, 2099, 2131, 2154, 2185, 2201, 2231, 2257, 2288, 2317, 2340,
	    2369, 2230,
	1762, 1872, 1867, 1876, 1885, 1883, 1901, 1904, 1928, 1849, 1852, 1950,
	    1993, 2071, 2112, 2132, 2166, 2185, 2219, 2245, 2275, 2306, 2334,
	    2359, 2222,
	1779, 1885, 1881, 1892, 1904, 1894, 1918, 1918, 1913, 1849, 1888, 1988,
	    2004, 2071, 2095, 2118, 2153, 2168, 2208, 2231, 2261, 2295, 2322,
	    2350, 2221,
	1784, 1896, 1890, 1900, 1914, 1911, 1924, 1926, 1913, 1880, 1977, 1991,
	    2008, 2047, 2066, 2091, 2130, 2148, 2181, 2210, 2244, 2275, 2302,
	    2333, 2211,
	1811, 1921, 1916, 1925, 1939, 1940, 1954, 1958, 1977, 1995, 2004, 2017,
	    2032, 2036, 2055, 2081, 2119, 2138, 2173, 2198, 2233, 2268, 2294,
	    2323, 2203,
	1836, 1946, 1944, 1948, 1963, 1965, 1977, 1981, 2001, 2021, 2026, 2039,
	    2053, 2026, 2047, 2071, 2106, 2127, 2163, 2191, 2222, 2259, 2283,
	    2312, 2198,
	1857, 1973, 1973, 1981, 1988, 1985, 2002, 2005, 2026, 2045, 2053, 2065,
	    2079, 2011, 2037, 2063, 2100, 2121, 2154, 2187, 2219, 2252, 2280,
	    2306, 2190,
	1885, 2002, 2004, 2007, 2014, 2014, 2030, 2033, 2053, 2069, 2077, 2090,
	    2103, 1858, 2033, 2053, 2096, 2113, 2146, 2177, 2209, 2250, 2273,
	    2300, 2183,
	1916, 2030, 2031, 2036, 2045, 2040, 2063, 2065, 2085, 2094, 2105, 2119,
	    2135, 1856, 2033, 2047, 2094, 2103, 2151, 2175, 2207, 2246, 2276,
	    2301, 2175,
	1950, 2070, 2069, 2077, 2084, 2081, 2100, 2103, 2121, 2131, 2140, 2155,
	    2170, 1851, 2030, 2047, 2088, 2103, 2138, 2169, 2205, 2236, 2268,
	    2297, 2170,
	2049, 2169, 2175, 2174, 2184, 2187, 2200, 2205, 2227, 2251, 2257, 2284,
	    2333, 1802, 2009, 2019, 2042, 2078, 2112, 2138, 2176, 2210, 2241,
	    2276, 2168
};

static short FullRawCapLowerLimit_lensone_g760s[TOUCH_TX_DEFAULT *
						TOUCH_RX_DEFAULT] = {
	1764, 1835, 1830, 1849, 1858, 1843, 1872, 1880, 1896, 1909, 1932, 1941,
	    1954, 2240, 2255, 2268, 2295, 2313, 2336, 2350, 2361, 2386, 2394,
	    2414, 2317,
	1784, 1853, 1846, 1865, 1873, 1858, 1888, 1903, 1916, 1924, 1944, 1957,
	    1970, 2136, 2156, 2166, 2193, 2210, 2228, 2252, 2274, 2294, 2296,
	    2322, 2228,
	1798, 1865, 1857, 1872, 1883, 1867, 1897, 1905, 1916, 1934, 1951, 1958,
	    1962, 2098, 2130, 2143, 2173, 2183, 2207, 2215, 2235, 2264, 2289,
	    2311, 2217,
	1809, 1872, 1863, 1884, 1893, 1879, 1910, 1913, 1927, 1939, 1956, 1967,
	    1975, 2075, 2105, 2122, 2147, 2171, 2191, 2204, 2227, 2254, 2273,
	    2302, 2203,
	1797, 1865, 1855, 1847, 1855, 1863, 1880, 1876, 1899, 1900, 1910, 1939,
	    1959, 2037, 2072, 2086, 2098, 2118, 2145, 2194, 2222, 2241, 2248,
	    2282, 2198,
	1798, 1867, 1862, 1849, 1855, 1868, 1887, 1885, 1912, 1911, 1921, 1952,
	    1971, 2012, 2047, 2058, 2070, 2093, 2145, 2182, 2206, 2228, 2247,
	    2280, 2196,
	1840, 1904, 1886, 1910, 1919, 1907, 1941, 1942, 1953, 1959, 1984, 1998,
	    2016, 2030, 2053, 2071, 2099, 2122, 2138, 2170, 2196, 2215, 2236,
	    2267, 2182,
	1870, 1927, 1918, 1938, 1941, 1940, 1965, 1958, 1976, 1988, 2009, 2023,
	    2037, 2025, 2044, 2063, 2093, 2060, 2133, 2163, 2184, 2209, 2233,
	    2263, 2177,
	1888, 1949, 1941, 1959, 1954, 1965, 1973, 1976, 1986, 2006, 2023, 2037,
	    2051, 2009, 2043, 2066, 2074, 2038, 2114, 2149, 2175, 2198, 2220,
	    2251, 2168,
	1910, 1979, 1972, 1991, 1982, 1993, 1999, 2000, 2012, 2034, 2045, 2058,
	    2071, 2000, 2033, 2056, 2067, 2095, 2117, 2141, 2166, 2189, 2208,
	    2241, 2173,
	1935, 2006, 1992, 2011, 2010, 2019, 2026, 2023, 2036, 2056, 2068, 2078,
	    2091, 1990, 2022, 2049, 2058, 2085, 2107, 2129, 2156, 2176, 2198,
	    2225, 2168,
	1971, 2030, 2019, 2037, 2042, 2049, 2051, 2047, 2065, 2080, 2098, 2108,
	    2125, 1990, 2021, 2048, 2056, 2084, 2107, 2128, 2159, 2182, 2200,
	    2226, 2168,
	2009, 2075, 2071, 2079, 2071, 2081, 2080, 2094, 2093, 2119, 2131, 2142,
	    2161, 1984, 2026, 2052, 2061, 2092, 2108, 2133, 2161, 2188, 2207,
	    2236, 2180,
	2119, 2189, 2182, 2196, 2206, 2193, 2217, 2223, 2236, 2257, 2270, 2286,
	    2350, 1981, 2019, 2046, 2071, 2100, 2117, 2145, 2177, 2204, 2218,
	    2250, 2186
};

static short FullRawCapLowerLimit_GIS[TOUCH_TX_DEFAULT * TOUCH_RX_DEFAULT] = {
	1748, 1767, 1766, 1758, 1757, 1757, 1743, 1743, 1734, 1729, 1724, 1721,
	    1776, 1511, 1512, 1505, 1497, 1492, 1500, 1488, 1488, 1464, 1469,
	    1468, 1411, 1381,
	1812, 1829, 1823, 1812, 1807, 1805, 1788, 1786, 1775, 1769, 1761, 1757,
	    1739, 1643, 1645, 1637, 1630, 1625, 1636, 1623, 1623, 1617, 1615,
	    1605, 1568, 1537,
	1808, 1823, 1817, 1805, 1799, 1796, 1778, 1776, 1763, 1756, 1748, 1742,
	    1718, 1643, 1643, 1636, 1628, 1624, 1634, 1622, 1622, 1616, 1614,
	    1604, 1576, 1616,
	1801, 1818, 1811, 1798, 1792, 1788, 1770, 1767, 1753, 1746, 1737, 1732,
	    1704, 1647, 1647, 1640, 1633, 1629, 1639, 1627, 1627, 1620, 1618,
	    1610, 1594, 1569,
	1791, 1810, 1803, 1790, 1784, 1780, 1762, 1758, 1744, 1737, 1727, 1723,
	    1693, 1653, 1652, 1645, 1639, 1634, 1645, 1633, 1633, 1627, 1624,
	    1615, 1609, 1528,
	1786, 1806, 1799, 1786, 1779, 1775, 1756, 1752, 1738, 1730, 1721, 1716,
	    1684, 1661, 1659, 1653, 1647, 1642, 1653, 1641, 1641, 1634, 1632,
	    1623, 1622, 1543,
	1782, 1801, 1793, 1780, 1773, 1768, 1749, 1746, 1730, 1723, 1713, 1708,
	    1676, 1670, 1666, 1660, 1653, 1650, 1660, 1648, 1648, 1641, 1639,
	    1630, 1632, 1670,
	1778, 1796, 1788, 1774, 1767, 1763, 1744, 1739, 1724, 1717, 1708, 1702,
	    1669, 1682, 1678, 1671, 1665, 1660, 1671, 1659, 1659, 1651, 1651,
	    1640, 1642, 1682,
	1774, 1792, 1784, 1771, 1763, 1759, 1740, 1735, 1721, 1713, 1704, 1699,
	    1664, 1694, 1689, 1683, 1677, 1673, 1684, 1673, 1673, 1666, 1665,
	    1655, 1655, 1586,
	1773, 1790, 1782, 1769, 1761, 1757, 1738, 1733, 1719, 1712, 1702, 1697,
	    1662, 1709, 1703, 1697, 1691, 1686, 1698, 1686, 1686, 1680, 1680,
	    1671, 1672, 1601,
	1770, 1788, 1780, 1766, 1758, 1754, 1735, 1731, 1716, 1709, 1699, 1694,
	    1659, 1723, 1716, 1711, 1704, 1700, 1711, 1700, 1700, 1694, 1693,
	    1686, 1688, 1662,
	1769, 1787, 1778, 1765, 1757, 1753, 1733, 1730, 1714, 1707, 1697, 1693,
	    1657, 1738, 1729, 1724, 1718, 1714, 1724, 1713, 1714, 1709, 1711,
	    1703, 1708, 1826,
	1766, 1785, 1777, 1763, 1757, 1753, 1735, 1731, 1716, 1709, 1700, 1696,
	    1659, 1766, 1752, 1747, 1743, 1738, 1749, 1739, 1740, 1736, 1738,
	    1731, 1733, 1703,
	1647, 1660, 1650, 1637, 1629, 1624, 1605, 1600, 1585, 1578, 1568, 1563,
	    1527, 2040, 1811, 1792, 1777, 1767, 1774, 1760, 1759, 1753, 1752,
	    1746, 1682, 1813
};

static short FullRawCapLowerLimit_YASSY[TOUCH_TX_DEFAULT * TOUCH_RX_DEFAULT] = {
	1621, 1790, 1785, 1785, 1779, 1773, 1769, 1763, 1757, 1753, 1750, 1744,
	    1794, 1504, 1504, 1498, 1492, 1488, 1479, 1481, 1471, 1474, 1467,
	    1463, 1424, 1326,
	1784, 1962, 1952, 1950, 1943, 1935, 1928, 1920, 1913, 1907, 1903, 1893,
	    1888, 1744, 1747, 1743, 1739, 1736, 1728, 1730, 1721, 1725, 1718,
	    1714, 1672, 1557,
	1775, 1954, 1942, 1939, 1930, 1922, 1915, 1906, 1896, 1890, 1883, 1874,
	    1864, 1746, 1749, 1744, 1741, 1738, 1729, 1732, 1722, 1726, 1720,
	    1715, 1674, 1601,
	1772, 1949, 1936, 1931, 1921, 1912, 1906, 1894, 1885, 1876, 1870, 1860,
	    1848, 1751, 1753, 1748, 1748, 1744, 1735, 1738, 1728, 1732, 1726,
	    1722, 1679, 1583,
	1767, 1942, 1930, 1924, 1913, 1903, 1895, 1885, 1874, 1868, 1859, 1849,
	    1838, 1761, 1761, 1756, 1756, 1752, 1743, 1748, 1738, 1740, 1734,
	    1730, 1686, 1571,
	1761, 1936, 1922, 1917, 1903, 1893, 1884, 1874, 1864, 1855, 1848, 1837,
	    1826, 1768, 1770, 1764, 1764, 1760, 1755, 1756, 1746, 1749, 1744,
	    1739, 1694, 1578,
	1756, 1930, 1916, 1910, 1896, 1886, 1877, 1867, 1857, 1848, 1839, 1830,
	    1815, 1778, 1779, 1774, 1773, 1770, 1765, 1765, 1755, 1758, 1754,
	    1749, 1703, 1630,
	1750, 1924, 1909, 1904, 1892, 1880, 1870, 1859, 1849, 1840, 1833, 1822,
	    1807, 1790, 1792, 1788, 1786, 1783, 1779, 1779, 1769, 1771, 1769,
	    1764, 1718, 1656,
	1747, 1919, 1905, 1900, 1887, 1873, 1864, 1854, 1841, 1832, 1825, 1814,
	    1797, 1803, 1803, 1800, 1798, 1797, 1793, 1793, 1783, 1787, 1783,
	    1779, 1732, 1621,
	1748, 1919, 1905, 1899, 1885, 1872, 1865, 1853, 1839, 1830, 1823, 1811,
	    1794, 1819, 1820, 1819, 1816, 1814, 1811, 1810, 1801, 1805, 1800,
	    1797, 1751, 1636,
	1746, 1917, 1904, 1895, 1883, 1869, 1860, 1849, 1836, 1827, 1821, 1809,
	    1792, 1838, 1840, 1837, 1836, 1835, 1832, 1831, 1822, 1826, 1821,
	    1818, 1771, 1680,
	1742, 1915, 1900, 1892, 1880, 1867, 1856, 1845, 1832, 1824, 1817, 1804,
	    1787, 1855, 1857, 1855, 1854, 1853, 1850, 1850, 1842, 1845, 1840,
	    1837, 1793, 1767,
	1742, 1914, 1900, 1893, 1879, 1867, 1857, 1845, 1832, 1824, 1817, 1806,
	    1789, 1885, 1883, 1882, 1882, 1882, 1880, 1879, 1873, 1876, 1871,
	    1869, 1821, 1716,
	1544, 1698, 1683, 1675, 1659, 1645, 1634, 1621, 1609, 1600, 1591, 1578,
	    1561, 1813, 1745, 1740, 1738, 1736, 1732, 1729, 1721, 1723, 1719,
	    1715, 1672, 1620
};

static short HighResistanceUpperLimit_oflim[3] = { 500, 450, -50 };	/*{365,135,-121};*/

static short HighResistanceUpperLimit_lensone[3] = { 500, 450, -100 };
static short HighResistanceUpperLimit_oflim_g760s[3] = { 894, 573, 0x14 };
static short HighResistanceUpperLimit_lensone_g760s[3] = { 794, 600, 0x14 };
static short HighResistanceUpperLimit_GIS[3] = { 800, 450, -50 };	/*{351,133,-163};*/
static short HighResistanceUpperLimit_YASSY[3] = { 800, 450, -50 };	/*{669,300,-140};*/

static short HighResistanceLowerLimit_oflim[3] = { 0, 0, -600 };	/*{227,28,-374};*/
static short HighResistanceLowerLimit_lensone[3] = { 0, 0, -600 };
static short HighResistanceLowerLimit_oflim_g760s[3] = { 0, 0, 0xfb50 };
static short HighResistanceLowerLimit_lensone_g760s[3] = { 0, 0, 0xfd21 };
static short HighResistanceLowerLimit_GIS[3] = { 0, 0, -600 };	/*{275,56    ,-238}*/
static short HighResistanceLowerLimit_YASSY[3] = { 0, 0, -600 };	/*{249,208,-305}*/

static int RxDiagonalUpperLimit_oflim = 1100;
static int RxDiagonalUpperLimit_lensone = 1100;
static int RxDiagonalUpperLimit_oflim_g760s = 1150;
static int RxDiagonalUpperLimit_lensone_g760s = 1150;
static int RxDiagonalUpperLimit_GIS = 1100;
static int RxDiagonalUpperLimit_YASSY = 1100;

static int RxDiagonalLowerLimit_oflim = 900;
static int RxDiagonalLowerLimit_lensone = 900;
static int RxDiagonalLowerLimit_oflim_g760s = 850;
static int RxDiagonalLowerLimit_lensone_g760s = 850;
static int RxDiagonalLowerLimit_GIS = 900;
static int RxDiagonalLowerLimit_YASSY = 900;

static short FullRawMaxCap;
static short FullRawMinCap;

static short *FullRawCapUpperLimit;
static short *FullRawCapLowerLimit;

static short *HighResistanceUpperLimit;
static short *HighResistanceLowerLimit;

static int RxDiagonalUpperLimit;
static int RxDiagonalLowerLimit;


static int RxOthersUpperLimit = 250;
static char TxTxReportLimit;
enum mmi_results {
	TEST_FAILED,
	TEST_PASS,
};
static char tp_test_failed_reason[TP_TEST_FAILED_REASON_LEN] = { "-software_reason" };
static char *g_mmi_buf_f54test_result;
static char *g_mmi_highresistance_report;
static char *g_mmi_maxmincapacitance_report;
static char *g_mmi_RxtoRxshort_report;
static char *g_mmi_buf_f54raw_data;
static char *g_buf_debug_data;
extern struct ts_data g_ts_data;
static char g_synaptics_trigger_log_flag;
#endif

static int synaptics_rmi4_f54_attention(void);

struct f54_query {
	union {
		struct {
			/* query 0 */
			unsigned char num_of_rx_electrodes;

			/* query 1 */
			unsigned char num_of_tx_electrodes;

			/* query 2 */
			unsigned char f54_query2_b0__1:2;
			unsigned char has_baseline:1;
			unsigned char has_image8:1;
			unsigned char f54_query2_b4__5:2;
			unsigned char has_image16:1;
			unsigned char f54_query2_b7:1;

			/* queries 3.0 and 3.1 */
			unsigned short clock_rate;

			/* query 4 */
			unsigned char touch_controller_family;

			/* query 5 */
			unsigned char has_pixel_touch_threshold_adjustment:1;
			unsigned char f54_query5_b1__7:7;

			/* query 6 */
			unsigned char has_sensor_assignment:1;
			unsigned char has_interference_metric:1;
			unsigned char has_sense_frequency_control:1;
			unsigned char has_firmware_noise_mitigation:1;
			unsigned char has_ctrl11:1;
			unsigned char has_two_byte_report_rate:1;
			unsigned char has_one_byte_report_rate:1;
			unsigned char has_relaxation_control:1;

			/* query 7 */
			unsigned char curve_compensation_mode:2;
			unsigned char f54_query7_b2__7:6;

			/* query 8 */
			unsigned char f54_query8_b0:1;
			unsigned char has_iir_filter:1;
			unsigned char has_cmn_removal:1;
			unsigned char has_cmn_maximum:1;
			unsigned char has_touch_hysteresis:1;
			unsigned char has_edge_compensation:1;
			unsigned char has_per_frequency_noise_control:1;
			unsigned char has_enhanced_stretch:1;

			/* query 9 */
			unsigned char has_force_fast_relaxation:1;
			unsigned char has_multi_metric_state_machine:1;
			unsigned char has_signal_clarity:1;
			unsigned char has_variance_metric:1;
			unsigned char has_0d_relaxation_control:1;
			unsigned char has_0d_acquisition_control:1;
			unsigned char has_status:1;
			unsigned char has_slew_metric:1;

			/* query 10 */
			unsigned char has_h_blank:1;
			unsigned char has_v_blank:1;
			unsigned char has_long_h_blank:1;
			unsigned char has_startup_fast_relaxation:1;
			unsigned char has_esd_control:1;
			unsigned char has_noise_mitigation2:1;
			unsigned char has_noise_state:1;
			unsigned char has_energy_ratio_relaxation:1;

			/* query 11 */
			unsigned char has_excessive_noise_reporting:1;
			unsigned char has_slew_option:1;
			unsigned char has_two_overhead_bursts:1;
			unsigned char has_query13:1;
			unsigned char has_one_overhead_burst:1;
			unsigned char f54_query11_b5:1;
			unsigned char has_ctrl88:1;
			unsigned char has_query15:1;

			/* query 12 */
			unsigned char number_of_sensing_frequencies:4;
			unsigned char f54_query12_b4__7:4;

			/* query 13 */
			unsigned char has_ctrl86:1;
			unsigned char has_ctrl87:1;
			unsigned char has_ctrl87_sub0:1;
			unsigned char has_ctrl87_sub1:1;
			unsigned char has_ctrl87_sub2:1;
			unsigned char has_cidim:1;
			unsigned char has_noise_mitigation_enhancement:1;
			unsigned char has_rail_im:1;
		} __packed;
		unsigned char data[15];
	};
};

struct f54_control_0 {
	union {
		struct {
			unsigned char no_relax:1;
			unsigned char no_scan:1;
			unsigned char force_fast_relaxation:1;
			unsigned char startup_fast_relaxation:1;
			unsigned char gesture_cancels_sfr:1;
			unsigned char enable_energy_ratio_relaxation:1;
			unsigned char excessive_noise_attn_enable:1;
			unsigned char f54_control0_b7:1;
		} __packed;
		struct {
			unsigned char data[1];
			unsigned short address;
		} __packed;
	};
};

struct f54_control_1 {
	union {
		struct {
			unsigned char bursts_per_cluster:4;
			unsigned char f54_ctrl1_b4__7:4;
		} __packed;
		struct {
			unsigned char data[1];
			unsigned short address;
		} __packed;
	};
};

struct f54_control_2 {
	union {
		struct {
			unsigned short saturation_cap;
		} __packed;
		struct {
			unsigned char data[2];
			unsigned short address;
		} __packed;
	};
};

struct f54_control_3 {
	union {
		struct {
			unsigned char pixel_touch_threshold;
		} __packed;
		struct {
			unsigned char data[1];
			unsigned short address;
		} __packed;
	};
};

struct f54_control_4__6 {
	union {
		struct {
			/* control 4 */
			unsigned char rx_feedback_cap:2;
			unsigned char bias_current:2;
			unsigned char f54_ctrl4_b4__7:4;

			/* control 5 */
			unsigned char low_ref_cap:2;
			unsigned char low_ref_feedback_cap:2;
			unsigned char low_ref_polarity:1;
			unsigned char f54_ctrl5_b5__7:3;

			/* control 6 */
			unsigned char high_ref_cap:2;
			unsigned char high_ref_feedback_cap:2;
			unsigned char high_ref_polarity:1;
			unsigned char f54_ctrl6_b5__7:3;
		} __packed;
		struct {
			unsigned char data[3];
			unsigned short address;
		} __packed;
	};
};

struct f54_control_7 {
	union {
		struct {
			unsigned char cbc_cap:3;
			unsigned char cbc_polarity:1;
			unsigned char cbc_tx_carrier_selection:1;
			unsigned char f54_ctrl7_b5__7:3;
		} __packed;
		struct {
			unsigned char data[1];
			unsigned short address;
		} __packed;
	};
};

struct f54_control_8__9 {
	union {
		struct {
			/* control 8 */
			unsigned short integration_duration:10;
			unsigned short f54_ctrl8_b10__15:6;

			/* control 9 */
			unsigned char reset_duration;
		} __packed;
		struct {
			unsigned char data[3];
			unsigned short address;
		} __packed;
	};
};

struct f54_control_10 {
	union {
		struct {
			unsigned char noise_sensing_bursts_per_image:4;
			unsigned char f54_ctrl10_b4__7:4;
		} __packed;
		struct {
			unsigned char data[1];
			unsigned short address;
		} __packed;
	};
};

struct f54_control_11 {
	union {
		struct {
			unsigned short f54_ctrl11;
		} __packed;
		struct {
			unsigned char data[2];
			unsigned short address;
		} __packed;
	};
};

struct f54_control_12__13 {
	union {
		struct {
			/* control 12 */
			unsigned char slow_relaxation_rate;

			/* control 13 */
			unsigned char fast_relaxation_rate;
		} __packed;
		struct {
			unsigned char data[2];
			unsigned short address;
		} __packed;
	};
};

struct f54_control_14 {
	union {
		struct {
			unsigned char rxs_on_xaxis:1;
			unsigned char curve_comp_on_txs:1;
			unsigned char f54_ctrl14_b2__7:6;
		} __packed;
		struct {
			unsigned char data[1];
			unsigned short address;
		} __packed;
	};
};

struct f54_control_15n {
	unsigned char sensor_rx_assignment;
};

struct f54_control_15 {
	struct f54_control_15n *data;
	unsigned short address;
	unsigned char length;
};

struct f54_control_16n {
	unsigned char sensor_tx_assignment;
};

struct f54_control_16 {
	struct f54_control_16n *data;
	unsigned short address;
	unsigned char length;
};

struct f54_control_17n {
	unsigned char burst_count_b8__10:3;
	unsigned char disable:1;
	unsigned char f54_ctrl17_b4:1;
	unsigned char filter_bandwidth:3;
};

struct f54_control_17 {
	struct f54_control_17n *data;
	unsigned short address;
	unsigned char length;
};

struct f54_control_18n {
	unsigned char burst_count_b0__7;
};

struct f54_control_18 {
	struct f54_control_18n *data;
	unsigned short address;
	unsigned char length;
};

struct f54_control_19n {
	unsigned char stretch_duration;
};

struct f54_control_19 {
	struct f54_control_19n *data;
	unsigned short address;
	unsigned char length;
};

struct f54_control_20 {
	union {
		struct {
			unsigned char disable_noise_mitigation:1;
			unsigned char f54_ctrl20_b1__7:7;
		} __packed;
		struct {
			unsigned char data[1];
			unsigned short address;
		} __packed;
	};
};

struct f54_control_21 {
	union {
		struct {
			unsigned short freq_shift_noise_threshold;
		} __packed;
		struct {
			unsigned char data[2];
			unsigned short address;
		} __packed;
	};
};

struct f54_control_22__26 {
	union {
		struct {
			/* control 22 */
			unsigned char f54_ctrl22;

			/* control 23 */
			unsigned short medium_noise_threshold;

			/* control 24 */
			unsigned short high_noise_threshold;

			/* control 25 */
			unsigned char noise_density;

			/* control 26 */
			unsigned char frame_count;
		} __packed;
		struct {
			unsigned char data[7];
			unsigned short address;
		} __packed;
	};
};

struct f54_control_27 {
	union {
		struct {
			unsigned char iir_filter_coef;
		} __packed;
		struct {
			unsigned char data[1];
			unsigned short address;
		} __packed;
	};
};

struct f54_control_28 {
	union {
		struct {
			unsigned short quiet_threshold;
		} __packed;
		struct {
			unsigned char data[2];
			unsigned short address;
		} __packed;
	};
};

struct f54_control_29 {
	union {
		struct {
			/* control 29 */
			unsigned char f54_ctrl29_b0__6:7;
			unsigned char cmn_filter_disable:1;
		} __packed;
		struct {
			unsigned char data[1];
			unsigned short address;
		} __packed;
	};
};

struct f54_control_30 {
	union {
		struct {
			unsigned char cmn_filter_max;
		} __packed;
		struct {
			unsigned char data[1];
			unsigned short address;
		} __packed;
	};
};

struct f54_control_31 {
	union {
		struct {
			unsigned char touch_hysteresis;
		} __packed;
		struct {
			unsigned char data[1];
			unsigned short address;
		} __packed;
	};
};

struct f54_control_32__35 {
	union {
		struct {
			/* control 32 */
			unsigned short rx_low_edge_comp;

			/* control 33 */
			unsigned short rx_high_edge_comp;

			/* control 34 */
			unsigned short tx_low_edge_comp;

			/* control 35 */
			unsigned short tx_high_edge_comp;
		} __packed;
		struct {
			unsigned char data[8];
			unsigned short address;
		} __packed;
	};
};

struct f54_control_36n {
	unsigned char axis1_comp;
};

struct f54_control_36 {
	struct f54_control_36n *data;
	unsigned short address;
	unsigned char length;
};

struct f54_control_37n {
	unsigned char axis2_comp;
};

struct f54_control_37 {
	struct f54_control_37n *data;
	unsigned short address;
	unsigned char length;
};

struct f54_control_38n {
	unsigned char noise_control_1;
};

struct f54_control_38 {
	struct f54_control_38n *data;
	unsigned short address;
	unsigned char length;
};

struct f54_control_39n {
	unsigned char noise_control_2;
};

struct f54_control_39 {
	struct f54_control_39n *data;
	unsigned short address;
	unsigned char length;
};

struct f54_control_40n {
	unsigned char noise_control_3;
};

struct f54_control_40 {
	struct f54_control_40n *data;
	unsigned short address;
	unsigned char length;
};

struct f54_control_41 {
	union {
		struct {
			unsigned char no_signal_clarity:1;
			unsigned char f54_ctrl41_b1__7:7;
		} __packed;
		struct {
			unsigned char data[1];
			unsigned short address;
		} __packed;
	};
};

struct f54_control_57 {
	union {
		struct {
			unsigned char cbc_cap_0d:3;
			unsigned char cbc_polarity_0d:1;
			unsigned char cbc_tx_carrier_selection_0d:1;
			unsigned char f54_ctrl57_b5__7:3;
		} __packed;
		struct {
			unsigned char data[1];
			unsigned short address;
		} __packed;
	};
};

struct f54_control_88 {
	union {
		struct {
			unsigned char tx_low_reference_polarity:1;
			unsigned char tx_high_reference_polarity:1;
			unsigned char abs_low_reference_polarity:1;
			unsigned char abs_polarity:1;
			unsigned char cbc_polarity:1;
			unsigned char cbc_tx_carrier_selection:1;
			unsigned char charge_pump_enable:1;
			unsigned char cbc_abs_auto_servo:1;
		} __packed;
		struct {
			unsigned char data[1];
			unsigned short address;
		} __packed;
	};
};

struct f54_control {
	struct f54_control_0 *reg_0;
	struct f54_control_1 *reg_1;
	struct f54_control_2 *reg_2;
	struct f54_control_3 *reg_3;
	struct f54_control_4__6 *reg_4__6;
	struct f54_control_7 *reg_7;
	struct f54_control_8__9 *reg_8__9;
	struct f54_control_10 *reg_10;
	struct f54_control_11 *reg_11;
	struct f54_control_12__13 *reg_12__13;
	struct f54_control_14 *reg_14;
	struct f54_control_15 *reg_15;
	struct f54_control_16 *reg_16;
	struct f54_control_17 *reg_17;
	struct f54_control_18 *reg_18;
	struct f54_control_19 *reg_19;
	struct f54_control_20 *reg_20;
	struct f54_control_21 *reg_21;
	struct f54_control_22__26 *reg_22__26;
	struct f54_control_27 *reg_27;
	struct f54_control_28 *reg_28;
	struct f54_control_29 *reg_29;
	struct f54_control_30 *reg_30;
	struct f54_control_31 *reg_31;
	struct f54_control_32__35 *reg_32__35;
	struct f54_control_36 *reg_36;
	struct f54_control_37 *reg_37;
	struct f54_control_38 *reg_38;
	struct f54_control_39 *reg_39;
	struct f54_control_40 *reg_40;
	struct f54_control_41 *reg_41;
	struct f54_control_57 *reg_57;
	struct f54_control_88 *reg_88;
};

struct synaptics_rmi4_f54_handle {
	bool no_auto_cal;
	unsigned char status;
	unsigned char intr_mask;
	unsigned char intr_reg_num;
	unsigned char rx_assigned;
	unsigned char tx_assigned;
	unsigned char *report_data;
	unsigned short query_base_addr;
	unsigned short control_base_addr;
	unsigned short data_base_addr;
	unsigned short command_base_addr;
	unsigned short fifoindex;
	unsigned int report_size;
	unsigned int data_buffer_size;
	enum f54_report_types report_type;
	struct mutex status_mutex;
	struct mutex data_mutex;
	struct mutex control_mutex;
	struct f54_query query;
	struct f54_control control;
	struct kobject *attr_dir;
	struct hrtimer watchdog;
	struct work_struct timeout_work;
	struct delayed_work status_work;
	struct workqueue_struct *status_workqueue;
	struct synaptics_rmi4_exp_fn_ptr *fn_ptr;
	struct synaptics_rmi4_data *rmi4_data;
};

struct f55_query {
	union {
		struct {
			/* query 0 */
			unsigned char num_of_rx_electrodes;

			/* query 1 */
			unsigned char num_of_tx_electrodes;

			/* query 2 */
			unsigned char has_sensor_assignment:1;
			unsigned char has_edge_compensation:1;
			unsigned char curve_compensation_mode:2;
			unsigned char has_ctrl6:1;
			unsigned char has_alternate_transmitter_assignment:1;
			unsigned char has_single_layer_multi_touch:1;
			unsigned char has_query5:1;
		} __packed;
		unsigned char data[3];
	};
};

struct synaptics_rmi4_f55_handle {
	unsigned char *rx_assignment;
	unsigned char *tx_assignment;
	unsigned short query_base_addr;
	unsigned short control_base_addr;
	unsigned short data_base_addr;
	unsigned short command_base_addr;
	struct f55_query query;
};

show_prototype(tp_status)
    show_prototype(report_size)
    show_store_prototype(no_auto_cal)
    show_store_prototype(report_type)
    show_store_prototype(fifoindex)
    store_prototype(do_preparation)
    store_prototype(get_report)
    store_prototype(force_cal)
    store_prototype(resume_touch)
    show_prototype(num_of_mapped_rx)
    show_prototype(num_of_mapped_tx)
    show_prototype(num_of_rx_electrodes)
    show_prototype(num_of_tx_electrodes)
    show_prototype(has_image16)
    show_prototype(has_image8)
    show_prototype(has_baseline)
    show_prototype(clock_rate)
    show_prototype(touch_controller_family)
    show_prototype(has_pixel_touch_threshold_adjustment)
    show_prototype(has_sensor_assignment)
    show_prototype(has_interference_metric)
    show_prototype(has_sense_frequency_control)
    show_prototype(has_firmware_noise_mitigation)
    show_prototype(has_two_byte_report_rate)
    show_prototype(has_one_byte_report_rate)
    show_prototype(has_relaxation_control)
    show_prototype(curve_compensation_mode)
    show_prototype(has_iir_filter)
    show_prototype(has_cmn_removal)
    show_prototype(has_cmn_maximum)
    show_prototype(has_touch_hysteresis)
    show_prototype(has_edge_compensation)
    show_prototype(has_per_frequency_noise_control)
    show_prototype(has_signal_clarity)
    show_prototype(number_of_sensing_frequencies)

    show_store_prototype(no_relax)
    show_store_prototype(no_scan)
    show_store_prototype(bursts_per_cluster)
    show_store_prototype(saturation_cap)
    show_store_prototype(pixel_touch_threshold)
    show_store_prototype(rx_feedback_cap)
    show_store_prototype(low_ref_cap)
    show_store_prototype(low_ref_feedback_cap)
    show_store_prototype(low_ref_polarity)
    show_store_prototype(high_ref_cap)
    show_store_prototype(high_ref_feedback_cap)
    show_store_prototype(high_ref_polarity)
    show_store_prototype(cbc_cap)
    show_store_prototype(cbc_polarity)
    show_store_prototype(cbc_tx_carrier_selection)
    show_store_prototype(integration_duration)
    show_store_prototype(reset_duration)
    show_store_prototype(noise_sensing_bursts_per_image)
    show_store_prototype(slow_relaxation_rate)
    show_store_prototype(fast_relaxation_rate)
    show_store_prototype(rxs_on_xaxis)
    show_store_prototype(curve_comp_on_txs)
    show_prototype(sensor_rx_assignment)
    show_prototype(sensor_tx_assignment)
    show_prototype(burst_count)
    show_prototype(disable)
    show_prototype(filter_bandwidth)
    show_prototype(stretch_duration)
    show_store_prototype(disable_noise_mitigation)
    show_store_prototype(freq_shift_noise_threshold)
    show_store_prototype(medium_noise_threshold)
    show_store_prototype(high_noise_threshold)
    show_store_prototype(noise_density)
    show_store_prototype(frame_count)
    show_store_prototype(iir_filter_coef)
    show_store_prototype(quiet_threshold)
    show_store_prototype(cmn_filter_disable)
    show_store_prototype(cmn_filter_max)
    show_store_prototype(touch_hysteresis)
    show_store_prototype(rx_low_edge_comp)
    show_store_prototype(rx_high_edge_comp)
    show_store_prototype(tx_low_edge_comp)
    show_store_prototype(tx_high_edge_comp)
    show_store_prototype(axis1_comp)
    show_store_prototype(axis2_comp)
    show_prototype(noise_control_1)
    show_prototype(noise_control_2)
    show_prototype(noise_control_3)
    show_store_prototype(no_signal_clarity)
    show_store_prototype(cbc_cap_0d)
    show_store_prototype(cbc_polarity_0d)
    show_store_prototype(cbc_tx_carrier_selection_0d)
/*Add synaptics capacitor test function */
#ifdef MMITEST
    show_prototype(mmi_test)
    show_prototype(mmi_test_result)
#endif
static ssize_t synaptics_rmi4_f54_data_read(struct file *data_file,
					    struct kobject *kobj,
					    struct bin_attribute *attributes,
					    char *buf, loff_t pos,
					    size_t count);

static struct attribute *attrs[] = {
	attrify(tp_status),
	attrify(report_size),
	attrify(no_auto_cal),
	attrify(report_type),
	attrify(fifoindex),
	attrify(do_preparation),
	attrify(get_report),
	attrify(force_cal),
	attrify(resume_touch),
	attrify(num_of_mapped_rx),
	attrify(num_of_mapped_tx),
	attrify(num_of_rx_electrodes),
	attrify(num_of_tx_electrodes),
	attrify(has_image16),
	attrify(has_image8),
	attrify(has_baseline),
	attrify(clock_rate),
	attrify(touch_controller_family),
	attrify(has_pixel_touch_threshold_adjustment),
	attrify(has_sensor_assignment),
	attrify(has_interference_metric),
	attrify(has_sense_frequency_control),
	attrify(has_firmware_noise_mitigation),
	attrify(has_two_byte_report_rate),
	attrify(has_one_byte_report_rate),
	attrify(has_relaxation_control),
	attrify(curve_compensation_mode),
	attrify(has_iir_filter),
	attrify(has_cmn_removal),
	attrify(has_cmn_maximum),
	attrify(has_touch_hysteresis),
	attrify(has_edge_compensation),
	attrify(has_per_frequency_noise_control),
	attrify(has_signal_clarity),
	attrify(number_of_sensing_frequencies),
#ifdef MMITEST
	attrify(mmi_test),
	attrify(mmi_test_result),
#endif
	NULL,
};

static struct attribute_group attr_group = GROUP(attrs);

static struct attribute *attrs_reg_0[] = {
	attrify(no_relax),
	attrify(no_scan),
	NULL,
};

static struct attribute *attrs_reg_1[] = {
	attrify(bursts_per_cluster),
	NULL,
};

static struct attribute *attrs_reg_2[] = {
	attrify(saturation_cap),
	NULL,
};

static struct attribute *attrs_reg_3[] = {
	attrify(pixel_touch_threshold),
	NULL,
};

static struct attribute *attrs_reg_4__6[] = {
	attrify(rx_feedback_cap),
	attrify(low_ref_cap),
	attrify(low_ref_feedback_cap),
	attrify(low_ref_polarity),
	attrify(high_ref_cap),
	attrify(high_ref_feedback_cap),
	attrify(high_ref_polarity),
	NULL,
};

static struct attribute *attrs_reg_7[] = {
	attrify(cbc_cap),
	attrify(cbc_polarity),
	attrify(cbc_tx_carrier_selection),
	NULL,
};

static struct attribute *attrs_reg_8__9[] = {
	attrify(integration_duration),
	attrify(reset_duration),
	NULL,
};

static struct attribute *attrs_reg_10[] = {
	attrify(noise_sensing_bursts_per_image),
	NULL,
};

static struct attribute *attrs_reg_11[] = {
	NULL,
};

static struct attribute *attrs_reg_12__13[] = {
	attrify(slow_relaxation_rate),
	attrify(fast_relaxation_rate),
	NULL,
};

static struct attribute *attrs_reg_14__16[] = {
	attrify(rxs_on_xaxis),
	attrify(curve_comp_on_txs),
	attrify(sensor_rx_assignment),
	attrify(sensor_tx_assignment),
	NULL,
};

static struct attribute *attrs_reg_17__19[] = {
	attrify(burst_count),
	attrify(disable),
	attrify(filter_bandwidth),
	attrify(stretch_duration),
	NULL,
};

static struct attribute *attrs_reg_20[] = {
	attrify(disable_noise_mitigation),
	NULL,
};

static struct attribute *attrs_reg_21[] = {
	attrify(freq_shift_noise_threshold),
	NULL,
};

static struct attribute *attrs_reg_22__26[] = {
	attrify(medium_noise_threshold),
	attrify(high_noise_threshold),
	attrify(noise_density),
	attrify(frame_count),
	NULL,
};

static struct attribute *attrs_reg_27[] = {
	attrify(iir_filter_coef),
	NULL,
};

static struct attribute *attrs_reg_28[] = {
	attrify(quiet_threshold),
	NULL,
};

static struct attribute *attrs_reg_29[] = {
	attrify(cmn_filter_disable),
	NULL,
};

static struct attribute *attrs_reg_30[] = {
	attrify(cmn_filter_max),
	NULL,
};

static struct attribute *attrs_reg_31[] = {
	attrify(touch_hysteresis),
	NULL,
};

static struct attribute *attrs_reg_32__35[] = {
	attrify(rx_low_edge_comp),
	attrify(rx_high_edge_comp),
	attrify(tx_low_edge_comp),
	attrify(tx_high_edge_comp),
	NULL,
};

static struct attribute *attrs_reg_36[] = {
	attrify(axis1_comp),
	NULL,
};

static struct attribute *attrs_reg_37[] = {
	attrify(axis2_comp),
	NULL,
};

static struct attribute *attrs_reg_38__40[] = {
	attrify(noise_control_1),
	attrify(noise_control_2),
	attrify(noise_control_3),
	NULL,
};

static struct attribute *attrs_reg_41[] = {
	attrify(no_signal_clarity),
	NULL,
};

static struct attribute *attrs_reg_57[] = {
	attrify(cbc_cap_0d),
	attrify(cbc_polarity_0d),
	attrify(cbc_tx_carrier_selection_0d),
	NULL,
};

static struct attribute_group attrs_ctrl_regs[] = {
	GROUP(attrs_reg_0),
	GROUP(attrs_reg_1),
	GROUP(attrs_reg_2),
	GROUP(attrs_reg_3),
	GROUP(attrs_reg_4__6),
	GROUP(attrs_reg_7),
	GROUP(attrs_reg_8__9),
	GROUP(attrs_reg_10),
	GROUP(attrs_reg_11),
	GROUP(attrs_reg_12__13),
	GROUP(attrs_reg_14__16),
	GROUP(attrs_reg_17__19),
	GROUP(attrs_reg_20),
	GROUP(attrs_reg_21),
	GROUP(attrs_reg_22__26),
	GROUP(attrs_reg_27),
	GROUP(attrs_reg_28),
	GROUP(attrs_reg_29),
	GROUP(attrs_reg_30),
	GROUP(attrs_reg_31),
	GROUP(attrs_reg_32__35),
	GROUP(attrs_reg_36),
	GROUP(attrs_reg_37),
	GROUP(attrs_reg_38__40),
	GROUP(attrs_reg_41),
	GROUP(attrs_reg_57),
};

static bool attrs_ctrl_regs_exist[ARRAY_SIZE(attrs_ctrl_regs)];

static struct bin_attribute dev_report_data = {
	.attr = {
		 .name = "report_data",
		 .mode = S_IRUGO,
		 },
	.size = 0,
	.read = synaptics_rmi4_f54_data_read,
};

static struct synaptics_rmi4_f54_handle *f54;
static struct synaptics_rmi4_f55_handle *f55;

DECLARE_COMPLETION(f54_s3207_remove_complete);

static bool is_report_type_valid(enum f54_report_types report_type)
{
	switch (report_type) {
	case F54_8BIT_IMAGE:
	case F54_16BIT_IMAGE:
	case F54_RAW_16BIT_IMAGE:
	case F54_HIGH_RESISTANCE:
	case F54_TX_TO_TX_SHORT:
	case F54_RX_TO_RX1:
	case F54_TRUE_BASELINE:
	case F54_FULL_RAW_CAP_MIN_MAX:
	case F54_RX_OPENS1:
	case F54_TX_OPEN:
	case F54_TX_TO_GROUND:
	case F54_RX_TO_RX2:
	case F54_RX_OPENS2:
	case F54_FULL_RAW_CAP:
	case F54_FULL_RAW_CAP_RX_COUPLING_COMP:
	case F54_SENSOR_SPEED:
	case F54_ADC_RANGE:
	case F54_TREX_OPENS:
	case F54_TREX_TO_GND:
	case F54_TREX_SHORTS:
		return true;
		break;
	default:
		f54->report_type = INVALID_REPORT_TYPE;
		f54->report_size = 0;
		return false;
	}
}

static void set_report_size(void)
{
	int retval;
	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;
	rx = f54->rx_assigned;
	tx = f54->tx_assigned;

	switch (f54->report_type) {
	case F54_8BIT_IMAGE:
		f54->report_size = rx * tx;
		break;
	case F54_16BIT_IMAGE:
	case F54_RAW_16BIT_IMAGE:
	case F54_TRUE_BASELINE:
	case F54_FULL_RAW_CAP:
	case F54_FULL_RAW_CAP_RX_COUPLING_COMP:
	case F54_SENSOR_SPEED:
		f54->report_size = 2 * rx * tx;
		break;
	case F54_HIGH_RESISTANCE:
		f54->report_size = HIGH_RESISTANCE_DATA_SIZE;
		break;
	case F54_TX_TO_TX_SHORT:
	case F54_TX_OPEN:
	case F54_TX_TO_GROUND:
		f54->report_size = 3;	/*(tx + 7) / 8; */
		break;
	case F54_RX_TO_RX1:
	case F54_RX_OPENS1:
		if (rx < tx)
			f54->report_size = 2 * rx * rx;
		else
			f54->report_size = 2 * rx * tx;
		break;
	case F54_FULL_RAW_CAP_MIN_MAX:
		f54->report_size = FULL_RAW_CAP_MIN_MAX_DATA_SIZE;
		break;
	case F54_RX_TO_RX2:
	case F54_RX_OPENS2:
		if (rx <= tx)
			f54->report_size = 0;
		else
			f54->report_size = 2 * rx * (rx - tx);
		break;
	case F54_ADC_RANGE:
		if (f54->query.has_signal_clarity) {
			mutex_lock(&f54->control_mutex);
			retval = f54->fn_ptr->read(rmi4_data,
						   f54->control.reg_41->address,
						   f54->control.reg_41->data,
						   sizeof(f54->control.reg_41->
							  data));
			mutex_unlock(&f54->control_mutex);
			if (retval < 0) {
				TS_LOG_ERR
				    ("%s: Failed to read control reg_41\n",
				     __func__);
				f54->report_size = 0;
				break;
			}
			if (!f54->control.reg_41->no_signal_clarity) {
				if (tx % 4)
					tx += 4 - (tx % 4);
			}
		}
		f54->report_size = 2 * rx * tx;
		break;
	case F54_TREX_OPENS:
	case F54_TREX_TO_GND:
	case F54_TREX_SHORTS:
		f54->report_size = TREX_DATA_SIZE;
		break;
	default:
		f54->report_size = 0;
	}

	return;
}

static int do_preparation(void)
{
	int retval;
	unsigned char value;
	unsigned char command;
	unsigned char timeout_count;
	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;

	mutex_lock(&f54->control_mutex);

	if (f54->query.touch_controller_family == 1) {
		value = 0;
		retval = f54->fn_ptr->write(rmi4_data,
					    f54->control.reg_7->address,
					    &value,
					    sizeof(f54->control.reg_7->data));
		if (retval < 0) {
			TS_LOG_ERR("%s: Failed to disable CBC\n", __func__);
			mutex_unlock(&f54->control_mutex);
			return retval;
		}
	} else if (f54->query.has_ctrl88 == 1) {
		retval = f54->fn_ptr->read(rmi4_data,
					   f54->control.reg_88->address,
					   f54->control.reg_88->data,
					   sizeof(f54->control.reg_88->data));
		if (retval < 0) {
			TS_LOG_ERR("%s: Failed to disable CBC (read ctrl88)\n",
				   __func__);
			mutex_unlock(&f54->control_mutex);
			return retval;
		}
		f54->control.reg_88->cbc_polarity = 0;
		f54->control.reg_88->cbc_tx_carrier_selection = 0;
		retval = f54->fn_ptr->write(rmi4_data,
					    f54->control.reg_88->address,
					    f54->control.reg_88->data,
					    sizeof(f54->control.reg_88->data));
		if (retval < 0) {
			TS_LOG_ERR("%s: Failed to disable CBC (write ctrl88)\n",
				   __func__);
			mutex_unlock(&f54->control_mutex);
			return retval;
		}
	}

	if (f54->query.has_0d_acquisition_control) {
		value = 0;
		retval = f54->fn_ptr->write(rmi4_data,
					    f54->control.reg_57->address,
					    &value,
					    sizeof(f54->control.reg_57->data));
		if (retval < 0) {
			TS_LOG_ERR("%s: Failed to disable 0D CBC\n", __func__);
			mutex_unlock(&f54->control_mutex);
			return retval;
		}
	}

	if (f54->query.has_signal_clarity) {
		value = 1;
		retval = f54->fn_ptr->write(rmi4_data,
					    f54->control.reg_41->address,
					    &value,
					    sizeof(f54->control.reg_41->data));
		if (retval < 0) {
			TS_LOG_ERR("%s: Failed to disable signal clarity\n",
				   __func__);
			mutex_unlock(&f54->control_mutex);
			return retval;
		}
	}

	mutex_unlock(&f54->control_mutex);

	command = (unsigned char)COMMAND_FORCE_UPDATE;

	retval = f54->fn_ptr->write(rmi4_data,
				    f54->command_base_addr,
				    &command, sizeof(command));
	if (retval < 0) {
		TS_LOG_ERR("%s: Failed to write force update command\n",
			   __func__);
		return retval;
	}

	timeout_count = 0;
	do {
		retval = f54->fn_ptr->read(rmi4_data,
					   f54->command_base_addr,
					   &value, sizeof(value));
		if (retval < 0) {
			TS_LOG_ERR("%s: Failed to read command register\n",
				   __func__);
			return retval;
		}

		if (value == 0x00)
			break;

		msleep(100);
		timeout_count++;
	} while (timeout_count < FORCE_TIMEOUT_100MS);

	if (timeout_count == FORCE_TIMEOUT_100MS) {
		TS_LOG_ERR("%s: Timed out waiting for force update\n",
			   __func__);
		return -ETIMEDOUT;
	}

	command = (unsigned char)COMMAND_FORCE_CAL;

	retval = f54->fn_ptr->write(rmi4_data,
				    f54->command_base_addr,
				    &command, sizeof(command));
	if (retval < 0) {
		TS_LOG_ERR("%s: Failed to write force cal command\n", __func__);
		return retval;
	}

	timeout_count = 0;
	do {
		retval = f54->fn_ptr->read(rmi4_data,
					   f54->command_base_addr,
					   &value, sizeof(value));
		if (retval < 0) {
			TS_LOG_ERR("%s: Failed to read command register\n",
				   __func__);
			return retval;
		}

		if (value == 0x00)
			break;

		msleep(100);
		timeout_count++;
	} while (timeout_count < FORCE_TIMEOUT_100MS);

	if (timeout_count == FORCE_TIMEOUT_100MS) {
		TS_LOG_ERR("%s: Timed out waiting for force cal\n", __func__);
		return -ETIMEDOUT;
	}

	return 0;
}

#ifdef WATCHDOG_HRTIMER
static void timeout_set_status(struct work_struct *work)
{
	int retval;
	unsigned char command;
	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;

	TS_LOG_INFO("watchdog timeout f54->status is %d\n", f54->status);

	mutex_lock(&f54->status_mutex);
	if (f54->status == STATUS_BUSY) {
		retval = f54->fn_ptr->read(rmi4_data,
					   f54->command_base_addr,
					   &command, sizeof(command));
		if (retval < 0) {
			TS_LOG_ERR("%s: Failed to read command register\n",
				   __func__);
		} else if (command & COMMAND_GET_REPORT) {
			TS_LOG_ERR("%s: Report type not supported by FW\n",
				   __func__);
		} else {
			queue_delayed_work(f54->status_workqueue,
					   &f54->status_work, 0);
			mutex_unlock(&f54->status_mutex);
			return;
		}
		f54->report_type = INVALID_REPORT_TYPE;
		f54->report_size = 0;
		f54->status = STATUS_IDLE;
	}
	mutex_unlock(&f54->status_mutex);

	return;
}

static enum hrtimer_restart get_report_timeout(struct hrtimer *timer)
{
	TS_LOG_DEBUG("%s:in!\n", __func__);
	schedule_work(&(f54->timeout_work));

	return HRTIMER_NORESTART;
}
#endif

#ifdef RAW_HEX
static void print_raw_hex_report(void)
{
	unsigned int ii;

	pr_info("%s: Report data (raw hex)\n", __func__);

	switch (f54->report_type) {
	case F54_16BIT_IMAGE:
	case F54_RAW_16BIT_IMAGE:
	case F54_HIGH_RESISTANCE:
	case F54_TRUE_BASELINE:
	case F54_FULL_RAW_CAP_MIN_MAX:
	case F54_FULL_RAW_CAP:
	case F54_FULL_RAW_CAP_RX_COUPLING_COMP:
	case F54_SENSOR_SPEED:
	case F54_ADC_RANGE:
		for (ii = 0; ii < f54->report_size; ii += 2) {
			pr_info("%03d: 0x%02x%02x\n",
				ii / 2,
				f54->report_data[ii + 1], f54->report_data[ii]);
		}
		break;
	default:
		for (ii = 0; ii < f54->report_size; ii++)
			pr_info("%03d: 0x%02x\n", ii, f54->report_data[ii]);
		break;
	}

	return;
}
#endif

#ifdef HUMAN_READABLE
static void print_image_report(void)
{
	unsigned int ii;
	unsigned int jj;
	short *report_data;

	switch (f54->report_type) {
	case F54_16BIT_IMAGE:
	case F54_RAW_16BIT_IMAGE:
	case F54_TRUE_BASELINE:
	case F54_FULL_RAW_CAP:
	case F54_FULL_RAW_CAP_RX_COUPLING_COMP:
		pr_info("%s: Report data (image)\n", __func__);

		report_data = (short *)f54->report_data;

		for (ii = 0; ii < f54->tx_assigned; ii++) {
			for (jj = 0; jj < f54->rx_assigned; jj++) {
				if (*report_data < -64)
					pr_cont(".");
				else if (*report_data < 0)
					pr_cont("-");
				else if (*report_data > 64)
					pr_cont("*");
				else if (*report_data > 0)
					pr_cont("+");
				else
					pr_cont("0");

				report_data++;
			}
			pr_info("");
		}
		pr_info("%s: End of report\n", __func__);
		break;
	default:
		pr_info("%s: Image not supported for report type %d\n",
			__func__, f54->report_type);
	}

	return;
}
#endif

static void free_control_mem(void)
{
	struct f54_control control = f54->control;

	kfree(control.reg_0);
	kfree(control.reg_1);
	kfree(control.reg_2);
	kfree(control.reg_3);
	kfree(control.reg_4__6);
	kfree(control.reg_7);
	kfree(control.reg_8__9);
	kfree(control.reg_10);
	kfree(control.reg_11);
	kfree(control.reg_12__13);
	kfree(control.reg_14);
	kfree(control.reg_15);
	kfree(control.reg_16);
	kfree(control.reg_17);
	kfree(control.reg_18);
	kfree(control.reg_19);
	kfree(control.reg_20);
	kfree(control.reg_21);
	kfree(control.reg_22__26);
	kfree(control.reg_27);
	kfree(control.reg_28);
	kfree(control.reg_29);
	kfree(control.reg_30);
	kfree(control.reg_31);
	kfree(control.reg_32__35);
	kfree(control.reg_36);
	kfree(control.reg_37);
	kfree(control.reg_38);
	kfree(control.reg_39);
	kfree(control.reg_40);
	kfree(control.reg_41);
	kfree(control.reg_57);

	return;
}

/*
static void remove_sysfs(void)
{
	int reg_num;

	sysfs_remove_bin_file(f54->attr_dir, &dev_report_data);

	sysfs_remove_group(f54->attr_dir, &attr_group);

	for (reg_num = 0; reg_num < ARRAY_SIZE(attrs_ctrl_regs); reg_num++)
		sysfs_remove_group(f54->attr_dir, &attrs_ctrl_regs[reg_num]);

	kobject_put(f54->attr_dir);

	return;
}
*/
static ssize_t synaptics_rmi4_f54_tp_status_show(struct device *dev,
						 struct device_attribute *attr,
						 char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%u\n", f54->status);
}

static ssize_t synaptics_rmi4_f54_report_size_show(struct device *dev,
						   struct device_attribute
						   *attr, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%u\n", f54->report_size);
}

static ssize_t synaptics_rmi4_f54_no_auto_cal_show(struct device *dev,
						   struct device_attribute
						   *attr, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%u\n", f54->no_auto_cal);
}

static ssize_t synaptics_rmi4_f54_no_auto_cal_store(struct device *dev,
						    struct device_attribute
						    *attr, const char *buf,
						    size_t count)
{
	int retval;
	unsigned char data;
	unsigned long setting;
	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;

	retval = sstrtoul(buf, 10, &setting);
	if (retval)
		return retval;

	if (setting > 1)
		return -EINVAL;

	retval = f54->fn_ptr->read(rmi4_data,
				   f54->control_base_addr, &data, sizeof(data));
	if (retval < 0) {
		TS_LOG_ERR("%s: Failed to read control register\n", __func__);
		return retval;
	}

	if ((data & NO_AUTO_CAL_MASK) == setting)
		return count;

	data = (data & ~NO_AUTO_CAL_MASK) | (data & NO_AUTO_CAL_MASK);

	retval = f54->fn_ptr->write(rmi4_data,
				    f54->control_base_addr,
				    &data, sizeof(data));
	if (retval < 0) {
		TS_LOG_ERR("%s: Failed to write control register\n", __func__);
		return retval;
	}

	f54->no_auto_cal = (setting == 1);

	return count;
}

static ssize_t synaptics_rmi4_f54_report_type_show(struct device *dev,
						   struct device_attribute
						   *attr, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%u\n", f54->report_type);
}

/*Add synaptics capacitor test function */
#ifdef MMITEST
static int synaptics_rmi4_f54_report_type_set(char setting)
{
	int retval = 0;
	unsigned char data;
	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;

	if (!is_report_type_valid((enum f54_report_types)setting)) {
		TS_LOG_ERR("%s: Report type not supported by driver\n",
			   __func__);
		return -EINVAL;
	}

	mutex_lock(&f54->status_mutex);

	if (f54->status != STATUS_BUSY) {
		f54->report_type = (enum f54_report_types)setting;
		data = (unsigned char)setting;
		retval = f54->fn_ptr->write(rmi4_data,
					    f54->data_base_addr,
					    &data, sizeof(data));
		mutex_unlock(&f54->status_mutex);
		if (retval < 0) {
			TS_LOG_ERR("%s: Failed to write data register\n",
				   __func__);
			return retval;
		}
		return 0;
	} else {
		TS_LOG_ERR("%s: Previous get report still ongoing\n", __func__);
		mutex_unlock(&f54->status_mutex);
		return -EINVAL;
	}
}
#endif

static ssize_t synaptics_rmi4_f54_report_type_store(struct device *dev,
						    struct device_attribute
						    *attr, const char *buf,
						    size_t count)
{
	int retval;
	unsigned char data;
	unsigned long setting;
	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;

	retval = sstrtoul(buf, 10, &setting);
	if (retval)
		return retval;

	if (!is_report_type_valid((enum f54_report_types)setting)) {
		TS_LOG_ERR("%s: Report type not supported by driver\n",
			   __func__);
		return -EINVAL;
	}

	mutex_lock(&f54->status_mutex);

	if (f54->status != STATUS_BUSY) {
		f54->report_type = (enum f54_report_types)setting;
		data = (unsigned char)setting;
		retval = f54->fn_ptr->write(rmi4_data,
					    f54->data_base_addr,
					    &data, sizeof(data));
		mutex_unlock(&f54->status_mutex);
		if (retval < 0) {
			TS_LOG_ERR("%s: Failed to write data register\n",
				   __func__);
			return retval;
		}
		return count;
	} else {
		TS_LOG_ERR("%s: Previous get report still ongoing\n", __func__);
		mutex_unlock(&f54->status_mutex);
		return -EINVAL;
	}
}

static ssize_t synaptics_rmi4_f54_fifoindex_show(struct device *dev,
						 struct device_attribute *attr,
						 char *buf)
{
	int retval;
	unsigned char data[2];
	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;

	retval = f54->fn_ptr->read(rmi4_data,
				   f54->data_base_addr +
				   DATA_REPORT_INDEX_OFFSET, data,
				   sizeof(data));
	if (retval < 0) {
		TS_LOG_ERR("%s: Failed to read data registers\n", __func__);
		return retval;
	}

	batohs(&f54->fifoindex, data);

	return snprintf(buf, PAGE_SIZE, "%u\n", f54->fifoindex);
}

static ssize_t synaptics_rmi4_f54_fifoindex_store(struct device *dev,
						  struct device_attribute *attr,
						  const char *buf, size_t count)
{
	int retval;
	unsigned char data[2];
	unsigned long setting;
	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;

	retval = sstrtoul(buf, 10, &setting);
	if (retval)
		return retval;

	f54->fifoindex = setting;

	hstoba(data, (unsigned short)setting);

	retval = f54->fn_ptr->write(rmi4_data,
				    f54->data_base_addr +
				    DATA_REPORT_INDEX_OFFSET, data,
				    sizeof(data));
	if (retval < 0) {
		TS_LOG_ERR("%s: Failed to write data registers\n", __func__);
		return retval;
	}

	return count;
}

/*Add synaptics capacitor test function */
#ifdef MMITEST
static int synaptics_rmi4_f54_do_preparation_set(void)
{
	int retval;
	/*struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data; */

	mutex_lock(&f54->status_mutex);

	if (f54->status != STATUS_IDLE) {
		if (f54->status != STATUS_BUSY) {
			TS_LOG_ERR("%s: Invalid status (%d)\n", __func__,
				   f54->status);
		} else {
			TS_LOG_ERR("%s: Previous get report still ongoing\n",
				   __func__);
		}
		mutex_unlock(&f54->status_mutex);
		return -EBUSY;
	}

	mutex_unlock(&f54->status_mutex);

	retval = do_preparation();
	if (retval < 0) {
		TS_LOG_ERR("%s: Failed to do preparation\n", __func__);
		return retval;
	}
	return 0;
}
#endif

static ssize_t synaptics_rmi4_f54_do_preparation_store(struct device *dev,
						       struct device_attribute
						       *attr, const char *buf,
						       size_t count)
{
	int retval;
	unsigned long setting;
	/*/struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data; */

	retval = sstrtoul(buf, 10, &setting);
	if (retval)
		return retval;

	if (setting != 1)
		return -EINVAL;

	mutex_lock(&f54->status_mutex);

	if (f54->status != STATUS_IDLE) {
		if (f54->status != STATUS_BUSY) {
			TS_LOG_ERR("%s: Invalid status (%d)\n", __func__,
				   f54->status);
		} else {
			TS_LOG_ERR("%s: Previous get report still ongoing\n",
				   __func__);
		}
		mutex_unlock(&f54->status_mutex);
		return -EBUSY;
	}

	mutex_unlock(&f54->status_mutex);

	retval = do_preparation();
	if (retval < 0) {
		TS_LOG_ERR("%s: Failed to do preparation\n", __func__);
		return retval;
	}

	return count;
}

/*Add synaptics capacitor test function */
#ifdef MMITEST
static ssize_t synaptics_rmi4_f54_get_report_set(char setting)
{
	int retval;
	unsigned char command;
	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;

	if (setting != 1)
		return -EINVAL;

	command = (unsigned char)COMMAND_GET_REPORT;

	if (!is_report_type_valid(f54->report_type)) {
		TS_LOG_ERR("%s: Invalid report type\n", __func__);
		return -EINVAL;
	}

	mutex_lock(&f54->status_mutex);

	if (f54->status != STATUS_IDLE) {
		if (f54->status != STATUS_BUSY) {
			TS_LOG_ERR("%s: Invalid status (%d)\n", __func__,
				   f54->status);
		} else {
			TS_LOG_ERR("%s: Previous get report still ongoing\n",
				   __func__);
		}
		mutex_unlock(&f54->status_mutex);
		return -EBUSY;
	}
	/*TS_LOG_ERR("to set interrupt\n");*/
	/*set_interrupt(true);*/

	f54->status = STATUS_BUSY;

	retval = f54->fn_ptr->write(rmi4_data,
				    f54->command_base_addr,
				    &command, sizeof(command));
	mutex_unlock(&f54->status_mutex);
	if (retval < 0) {
		TS_LOG_ERR("%s: Failed to write get report command\n",
			   __func__);
		return retval;
	}
#ifdef WATCHDOG_HRTIMER
	hrtimer_start(&f54->watchdog,
		      ktime_set(WATCHDOG_TIMEOUT_S, 0), HRTIMER_MODE_REL);
#endif

	return 0;
}
#endif

static ssize_t synaptics_rmi4_f54_get_report_store(struct device *dev,
						   struct device_attribute
						   *attr, const char *buf,
						   size_t count)
{
	int retval;
	unsigned char command;
	unsigned long setting;
	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;

	retval = sstrtoul(buf, 10, &setting);
	if (retval)
		return retval;

	if (setting != 1)
		return -EINVAL;

	command = (unsigned char)COMMAND_GET_REPORT;

	if (!is_report_type_valid(f54->report_type)) {
		TS_LOG_ERR("%s: Invalid report type\n", __func__);
		return -EINVAL;
	}

	mutex_lock(&f54->status_mutex);

	if (f54->status != STATUS_IDLE) {
		if (f54->status != STATUS_BUSY) {
			TS_LOG_ERR("%s: Invalid status (%d)\n", __func__,
				   f54->status);
		} else {
			TS_LOG_ERR("%s: Previous get report still ongoing\n",
				   __func__);
		}
		mutex_unlock(&f54->status_mutex);
		return -EBUSY;
	}
	/*set_interrupt(true);*/

	f54->status = STATUS_BUSY;

	retval = f54->fn_ptr->write(rmi4_data,
				    f54->command_base_addr,
				    &command, sizeof(command));
	mutex_unlock(&f54->status_mutex);
	if (retval < 0) {
		TS_LOG_ERR("%s: Failed to write get report command\n",
			   __func__);
		return retval;
	}
#ifdef WATCHDOG_HRTIMER
	hrtimer_start(&f54->watchdog,
		      ktime_set(WATCHDOG_TIMEOUT_S, 0), HRTIMER_MODE_REL);
#endif

	return count;
}

static ssize_t synaptics_rmi4_f54_force_cal_store(struct device *dev,
						  struct device_attribute *attr,
						  const char *buf, size_t count)
{
	int retval;
	unsigned char command;
	unsigned long setting;
	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;

	retval = sstrtoul(buf, 10, &setting);
	if (retval)
		return retval;

	if (setting != 1)
		return -EINVAL;

	command = (unsigned char)COMMAND_FORCE_CAL;

	if (f54->status == STATUS_BUSY)
		return -EBUSY;

	retval = f54->fn_ptr->write(rmi4_data,
				    f54->command_base_addr,
				    &command, sizeof(command));
	if (retval < 0) {
		TS_LOG_ERR("%s: Failed to write force cal command\n", __func__);
		return retval;
	}

	return count;
}

/*Add synaptics capacitor test function */
#ifdef MMITEST
static struct kobject *touch_screen_kobject_ts;

static struct kobject *tp_get_touch_screen_obj(void)
{
	if (NULL == touch_screen_kobject_ts) {
		touch_screen_kobject_ts =
		    kobject_create_and_add("touch_screen", NULL);
		if (!touch_screen_kobject_ts) {
			TS_LOG_ERR("create touch_screen kobjetct error!\n");
			return NULL;
		} else {
			TS_LOG_INFO(" create sys/touch_screen successful!\n");
		}
	} else {
		TS_LOG_INFO("sys/touch_screen already exist!\n");
	}

	return touch_screen_kobject_ts;
}

static void mmi_rawimage_report(unsigned char *buffer)
{
	int i, j, k = 0;
	short *DataArray;
	short temp;
	enum mmi_results TestResult = TEST_PASS;
	char buf[6];
	memset(g_mmi_buf_f54raw_data, 0,
	       (rx * tx * 6 + F54_MAX_CAP_TITLE_SIZE));
	sprintf(g_mmi_buf_f54raw_data, "RawImageData:\n");

	DataArray = (short *)kmalloc(sizeof(short) * tx * rx, GFP_KERNEL);
	if (DataArray == NULL) {
		TS_LOG_ERR("%s:kmalloc failed\n",__func__);
		return;
	}

	for (i = 0; i < tx; i++) {
		for (j = 0; j < rx; j++) {
			temp = buffer[k] | (buffer[k + 1] << 8);
			DataArray[i * rx + j] = temp;	/*float is not allowed in kernel space*/
			k = k + 2;

			sprintf(buf, "%d ", temp);
			strncat(g_mmi_buf_f54raw_data, buf, sizeof(buf));
		}
		strncat(g_mmi_buf_f54raw_data, "\n", 1);
	}

	for (i = 0; i < tx; i++) {
		for (j = 0; j < rx; j++) {
			if ((DataArray[i * rx + j] >
			     FullRawCapUpperLimit[i * rx + j])
			    || (DataArray[i * rx + j] <
				FullRawCapLowerLimit[i * rx + j])) {
				TestResult = TEST_FAILED;
				TS_LOG_ERR
				    ("%s: TEST_FAILED:1F-, RawCap(%d,%d) = %d \n",
				     __func__, i, j, DataArray[i * rx + j]);
			}
		}
	}

	if (TestResult) {
		strcat(g_mmi_buf_f54test_result, "1P-");
	} else {
		strcat(g_mmi_buf_f54test_result, "1F-");
		strncpy(tp_test_failed_reason, "panel_reason",
			TP_TEST_FAILED_REASON_LEN);
	}

	kfree(DataArray);
	return;
}

static int RxtoRx1ShortTest(unsigned char *buffer)
{

	int i, j, k = 0;
	int count = 0;
	int DiagonalUpperLimit = RxDiagonalUpperLimit;
	int DiagonalLowerLimit = RxDiagonalLowerLimit;
	int OthersUpperLimit = RxOthersUpperLimit;
	short ImageArray;
	char buf[6] = { 0 };

	for (i = 0; i < tx; i++) {
		for (j = 0; j < rx; j++) {
			ImageArray = buffer[k] | (buffer[k + 1] << 8);
			k = k + 2;
			snprintf(buf,sizeof(buf), "%5d ", ImageArray);

			if (i == j) {
				strncat(g_mmi_RxtoRxshort_report, buf,
					sizeof(buf));
				if ((ImageArray <= DiagonalUpperLimit)
				    && (ImageArray >= DiagonalLowerLimit))
					count++;
			} else {
				if (ImageArray <= OthersUpperLimit)
					count++;
			}
		}
		/*strncat(g_mmi_RxtoRxshort_report, "\n", 1);*/
	}
	return count;
}

static int RxtoRx2ShortTest(unsigned char *buffer)
{

	int i, j, k = 0;
	int count = 0;
	int DiagonalUpperLimit = RxDiagonalUpperLimit;
	int DiagonalLowerLimit = RxDiagonalLowerLimit;
	int OthersUpperLimit = RxOthersUpperLimit;
	short ImageArray;
	char buf[6] = { 0 };

	for (i = 0; i < (rx - tx); i++) {
		for (j = 0; j < rx; j++) {
			ImageArray = buffer[k] | (buffer[k + 1] << 8);
			k = k + 2;
			sprintf(buf, "%5d ", ImageArray);

			if ((i + tx) == j) {
				strncat(g_mmi_RxtoRxshort_report, buf,
					sizeof(buf));
				if ((ImageArray <= DiagonalUpperLimit)
				    && (ImageArray >= DiagonalLowerLimit))
					count++;
				else
					TS_LOG_ERR
					    ("%s: Failed,ImageArray(%d,%d) = %d\n",
					     __func__, i, j, ImageArray);
			} else {
				if (ImageArray <= OthersUpperLimit)
					count++;
				else
					TS_LOG_ERR
					    ("%s: Failed,ImageArray(%d,%d) = %d\n",
					     __func__, i, j, ImageArray);
			}
		}
		/*strncat(g_mmi_RxtoRxshort_report, "\n", 1);*/
	}
	strncat(g_mmi_RxtoRxshort_report, "\n", 1);
	return count;
}

static void mmi_RxtoRxshort1_report(unsigned char *buffer)
{

	int count = 0;
	/*enum mmi_results TestResult = TEST_PASS;*/
	memset(g_mmi_RxtoRxshort_report, 0, (6 * rx + F54_MAX_CAP_TITLE_SIZE));	/*only Diagonal for V3*/
	sprintf(g_mmi_RxtoRxshort_report, "RxtoRxshort:\n");

	count = RxtoRx1ShortTest(buffer);
	/*count += RxtoRx2ShortTest(buffer);*/

	if (count == (rx * rx)) {
		/*TestResult = TEST_PASS;*/
		strcat(g_mmi_buf_f54test_result, "4P-");
	} else {
		/*TestResult = TEST_FAILED;*/
		/*strcat(g_mmi_buf_f54test_result,"4F-");*/
		TS_LOG_ERR("%s:test failed,count = %d LINE = %d\n", __func__,
			   count, __LINE__);
	}

	return;
}

static void mmi_RxtoRxshort2_report(unsigned char *buffer)
{

	int count = tx * rx;
	/*enum mmi_results TestResult = TEST_PASS;*/

	count += RxtoRx2ShortTest(buffer);

	if (count == (rx * rx)) {
		/*TestResult = TEST_PASS;*/
		strcat(g_mmi_buf_f54test_result, "4P-");
	} else {
		/*TestResult = TEST_FAILED;*/
		strcat(g_mmi_buf_f54test_result, "4F-");
		strncpy(tp_test_failed_reason, "panel_reason",
			TP_TEST_FAILED_REASON_LEN);
	}

	return;
}

static void mmi_txtotx_short_report(unsigned char *buffer)
{
	int i, j, index;
	int numberOfBytes = (f54->tx_assigned + 7) / 8;
	char val;
	enum mmi_results TestResult = TEST_PASS;

	for (i = 0; i < numberOfBytes; i++) {
		for (j = 0; j < 8; j++) {
			index = i * 8 + j;
			if (index >= f54->tx_assigned)
				break;
			val = (buffer[i] & (1 << j)) >> j;
			if (numberOfBytes < tx) {
				if (val != TxTxReportLimit) {
					TestResult = TEST_FAILED;
					TS_LOG_ERR("%s: Failed,val(%d,%d) = %d",
						   __func__, i, j, val);
				}
			}
		}
	}

	if (TestResult) {
		strcat(g_mmi_buf_f54test_result, "2P-");
	} else {
		strcat(g_mmi_buf_f54test_result, "2F-");
		strncpy(tp_test_failed_reason, "panel_reason",
			TP_TEST_FAILED_REASON_LEN);
	}
	return;
}

static void mmi_txtoground_short_report(unsigned char *buffer,
					size_t report_size)
{
	/*enum mmi_results TestResult = TEST_PASS;*/

	char Txstatus;
	int result = 0;
	int i, j;

	for (i = 0; i < report_size; i++) {
		for (j = 0; j < 8; j++) {
			Txstatus = (buffer[i] & (1 << j)) >> j;
			if (1 == Txstatus)
				result++;
		}
	}

	if ((tx) == result) {
		/*TestResult = TEST_PASS;*/
		strcat(g_mmi_buf_f54test_result, "3P-");
	} else {
		TS_LOG_ERR("%s: Failed in txtoground, result = %d\n", __func__,
			   result);
		/*TestResult = TEST_FAILED;*/
		strcat(g_mmi_buf_f54test_result, "3F-");
		strncpy(tp_test_failed_reason, "panel_reason",
			TP_TEST_FAILED_REASON_LEN);
	}

	return;
}

static void mmi_maxmincapacitance_report(unsigned char *buffer)
{
	/*enum mmi_results TestResult = TEST_PASS;*/

	short maxcapacitance = FullRawMaxCap;
	short mincapacitance = FullRawMinCap;
	short max = 0;
	short min = 0;
	char buf[2 * 6] = { 0 };
	memset(g_mmi_maxmincapacitance_report, 0,
	       (2 * 6 + F54_MAX_CAP_TITLE_SIZE));
	sprintf(g_mmi_maxmincapacitance_report, "maxmincapacitance:\n");
	max = (buffer[0]) | (buffer[1] << 8);
	min = (buffer[2]) | (buffer[3] << 8);

	if ((max < maxcapacitance) && (min > mincapacitance)) {
		/*TestResult = TEST_PASS;*/
		strcat(g_mmi_buf_f54test_result, "5P-");
	} else {
		/*TestResult = TEST_FAILED;*/
		strcat(g_mmi_buf_f54test_result, "5F-");
		strncpy(tp_test_failed_reason, "panel_reason",
			TP_TEST_FAILED_REASON_LEN);
	}

	sprintf(buf, " %d %d", max, min);
	strncat(g_mmi_maxmincapacitance_report, buf, sizeof(buf));
	strncat(g_mmi_maxmincapacitance_report, "\n", 1);

	return;
}

static void mmi_highresistance_report(unsigned char *buffer)
{
	int i, k = 0;
	short temp;
	enum mmi_results TestResult = TEST_PASS;
	short HighResistanceResult[3];
	char buf[6] = { 0 };
	memset(g_mmi_highresistance_report, 0,
	       (3 * 6 + F54_MAX_CAP_TITLE_SIZE));
	sprintf(g_mmi_highresistance_report, "highresistance:\n");

	for (i = 0; i < 3; i++, k += 2) {
		temp = buffer[k] | (buffer[k + 1] << 8);
		HighResistanceResult[i] = temp;
		if ((HighResistanceResult[i] > HighResistanceUpperLimit[i]) ||
		    (HighResistanceResult[i] < HighResistanceLowerLimit[i])) {

			TestResult = TEST_FAILED;
			TS_LOG_ERR
			    ("%s: TEST_FAILED: 6F ,highresistance[%d] = %d \n",
			     __func__, i, HighResistanceResult[i]);
		}
		sprintf(buf, " %d ", HighResistanceResult[i]);
		strncat(g_mmi_highresistance_report, buf, sizeof(buf));
	}

	strncat(g_mmi_highresistance_report, "\n", 1);

	if (TestResult) {
		strcat(g_mmi_buf_f54test_result, "6P-");
	} else {
		strcat(g_mmi_buf_f54test_result, "6F-");
		strncpy(tp_test_failed_reason, "panel_reason",
			TP_TEST_FAILED_REASON_LEN);
	}
	return;
}

static void mmi_delta_report(unsigned char *buffer)
{
	int i, j, k = 0;
	short *DataArray;
	short temp;
	char buf[6];
	TS_LOG_INFO("mmi_delta_report\n");
	memset(g_buf_debug_data, 1,
	       (rx * tx * 6 + F54_MAX_CAP_TITLE_SIZE + F54_MAX_CAP_TITLE_SIZE +
		F54_MAX_CAP_TITLE_SIZE));
	sprintf(g_buf_debug_data, "delta_data:\n");

	DataArray = (short *)kmalloc(sizeof(short) * tx * rx, GFP_KERNEL);
	if (DataArray == NULL) {
		TS_LOG_ERR("%s:kmalloc failed\n",__func__);
		return;
	}
	for (i = 0; i < tx; i++) {
		for (j = 0; j < rx; j++) {
			temp = buffer[k] | (buffer[k + 1] << 8);
			DataArray[i * rx + j] = temp;	/*float is not allowed in kernel space*/
			k = k + 2;

			sprintf(buf, "%d ", temp);
			strncat(g_buf_debug_data, buf, sizeof(buf));
		}
		strcat(g_buf_debug_data, "\n");
	}

	kfree(DataArray);
	return;
}

static int mmi_runtest(int report_type)
{
	int retval = 0;
	unsigned char patience = 10;
	int report_size;
	unsigned char *buffer = NULL;
	unsigned char command;
	/*struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;*/

	/*TS_LOG_INFO("mmi test report type is %d",report_type);*/

	retval = synaptics_rmi4_f54_report_type_set(report_type);
	if (retval)
		goto test_exit;
	mdelay(5);
	retval = synaptics_rmi4_f54_get_report_set(1);
	if (retval) {
		TS_LOG_ERR
		    ("synaptics_rmi4_f54_get_report_set failed  retval=%d",
		     retval);
		goto test_exit;
	}
	while (patience != 0) {
		msleep(150);
		retval = f54->fn_ptr->read(f54->rmi4_data,
					   f54->command_base_addr,
					   &command, sizeof(command));
		if (retval) {
			TS_LOG_ERR("read command failed  retval=%d", retval);
			continue;
		}
		TS_LOG_DEBUG("command=%d", command);
		if (0 == (command & 0x01)) {
			break;
		}
		patience--;
	}
	retval = synaptics_rmi4_f54_attention();
	if (retval) {
		TS_LOG_ERR("synaptics_rmi4_f54_attention failed  retval=%d",
			   retval);
		goto test_exit;
	}

	report_size = f54->report_size;

	TS_LOG_INFO
	    ("mmi test report type is %d,report_size is %d,patience=%d, status=%d\n",
	     report_type, report_size, patience, f54->status);

	if (!report_size)
		goto test_exit;
	buffer = kmalloc(report_size, GFP_KERNEL);
	if (!buffer) {
		TS_LOG_ERR("%s: Faild to kzalloc %d buffer\n", __func__,
			   report_size);
		goto test_exit;
	}
	memset(buffer, 0, report_size);

	/*load test limit*/
	/*LoadHighResistanceLimits();*/

	/*simulate ReadBlockData()*/
	mutex_lock(&f54->data_mutex);

	if (f54->report_data) {
		memcpy(buffer, f54->report_data, f54->report_size);
		mutex_unlock(&f54->data_mutex);
	} else {
		mutex_unlock(&f54->data_mutex);
		goto test_exit;
	}
	switch (report_type) {
	case F54_FULL_RAW_CAP_MIN_MAX:
		if (!g_mmi_maxmincapacitance_report)
			g_mmi_maxmincapacitance_report =
			    kmalloc(2 * 6 + F54_MAX_CAP_TITLE_SIZE, GFP_KERNEL);
		mmi_maxmincapacitance_report(buffer);
		break;
	case F54_FULL_RAW_CAP_RX_COUPLING_COMP:
		if (!g_mmi_buf_f54raw_data)
			g_mmi_buf_f54raw_data =
			    kmalloc(rx * tx * 6 + F54_MAX_CAP_TITLE_SIZE,
				    GFP_KERNEL);
		mmi_rawimage_report(buffer);
		break;
	case F54_TX_TO_TX_SHORT:
		mmi_txtotx_short_report(buffer);
		break;
	case F54_HIGH_RESISTANCE:
		if (!g_mmi_highresistance_report)
			g_mmi_highresistance_report =
			    kmalloc(3 * 6 + F54_MAX_CAP_TITLE_SIZE, GFP_KERNEL);
		mmi_highresistance_report(buffer);
		break;
	case F54_TX_TO_GROUND:
		mmi_txtoground_short_report(buffer, report_size);
		break;
	case F54_RX_TO_RX1:
		if (!g_mmi_RxtoRxshort_report)
			g_mmi_RxtoRxshort_report =
			    kmalloc(6 * rx + F54_MAX_CAP_TITLE_SIZE,
				    GFP_KERNEL);
		mmi_RxtoRxshort1_report(buffer);
		break;
	case F54_RX_TO_RX2:
		/*g_mmi_RxtoRxshort_report = kmalloc(4536, GFP_KERNEL);*/
		mmi_RxtoRxshort2_report(buffer);
		break;
	case F54_16BIT_IMAGE:
		if (!g_buf_debug_data)
			g_buf_debug_data = kmalloc(rx * tx * 6 + F54_MAX_CAP_TITLE_SIZE + 4 * F54_MAX_CAP_TITLE_SIZE, GFP_KERNEL);	/*buf len for test*/
		mmi_delta_report(buffer);
		break;
	default:
		break;
	}
	kfree(buffer);
	return 0;

test_exit:
	TS_LOG_ERR("%s: Faild to run test\n", __func__);
	if (buffer)
		kfree(buffer);
	return -EINVAL;

}

static int synaptics_rmi4_irq_enable(bool enable)
{
	int retval = 0;

	unsigned short reg_addr = Interrupt_Enable_Addr;
	unsigned char reg_data;
	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;

	TS_LOG_INFO("%s;enable =%d\n", __func__, enable);
	retval = f54->fn_ptr->read(rmi4_data,
				   reg_addr, &reg_data, sizeof(reg_data));

	if (retval < 0) {
		TS_LOG_ERR("Failed to read reg, error = %d\n", retval);
		return retval;
	}

	if (IRQ_ON == enable) {
		reg_data |= IRQ_ENA_MASK_BIT;
	} else {
		reg_data &= ~IRQ_ENA_MASK_BIT;
	}

	retval = f54->fn_ptr->write(rmi4_data,
				    reg_addr, &reg_data, sizeof(reg_data));

	if (retval < 0) {
		TS_LOG_ERR("Failed to write reg, error = %d\n", retval);
	}
	return retval;
}

static ssize_t synaptics_rmi4_f54_mmi_test_show(struct device *dev,
						struct device_attribute *attr,
						char *buf)
{
	int retval = 0;
	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;
	TS_LOG_ERR("begin mmi test.\n");

	atomic_set(&g_ts_data.state, TS_MMI_CAP_TEST);
	if (!g_mmi_buf_f54test_result)
		g_mmi_buf_f54test_result = kmalloc(80, GFP_KERNEL);

	if (g_mmi_buf_f54test_result)
		memset(g_mmi_buf_f54test_result, 0, 80);
	else
		goto exit;
	retval = synaptics_rmi4_irq_enable(IRQ_OFF);
	retval = synaptics_rmi4_f54_do_preparation_set();
	if (retval) {
		TS_LOG_ERR("fail to do preparation set\n");
		goto exit;
	}
	sprintf(g_mmi_buf_f54test_result, "0P-");

	retval = mmi_runtest(F54_HIGH_RESISTANCE);
	if (retval)
		goto exit;

	retval = mmi_runtest(F54_FULL_RAW_CAP_MIN_MAX);
	if (retval)
		goto exit;

	retval = mmi_runtest(F54_FULL_RAW_CAP_RX_COUPLING_COMP);
	if (retval)
		goto exit;

	retval = mmi_runtest(F54_RX_TO_RX1);
	if (retval)
		goto exit;

	retval = mmi_runtest(F54_RX_TO_RX2);
	if (retval)
		goto exit;

	retval = mmi_runtest(F54_TX_TO_GROUND);
	if (retval)
		goto exit;

	retval = mmi_runtest(F54_TX_TO_TX_SHORT);
	if (retval)
		goto exit;
	if (0 == strlen(g_mmi_buf_f54test_result)
	    || strstr(g_mmi_buf_f54test_result, "F")) {
		strncat(g_mmi_buf_f54test_result, tp_test_failed_reason, 50);
	}

	switch (f54->rmi4_data->synaptics_chip_data->ic_type) {
	case SYNAPTICS_S3207:
		strncat(g_mmi_buf_f54test_result, "-synaptics_3207",
			strlen("-synaptics_3207"));
		break;
	case SYNAPTICS_S3350:
		strncat(g_mmi_buf_f54test_result, "-synaptics_3350",
			strlen("-synaptics_3350"));
		break;
	case SYNAPTICS_S3320:
		strncat(g_mmi_buf_f54test_result, "-synaptics_3320",
			strlen("-synaptics_3320"));
		break;
	case SYNAPTICS_S3718:
		strncat(g_mmi_buf_f54test_result, "-synaptics_3718",
			strlen("-synaptics_3718"));
		break;
	case SYNAPTICS_TD4322:
		strncat(g_mmi_buf_f54test_result, "-synaptics_4322",
			strlen("-synaptics_4322"));
		break;
	case SYNAPTICS_TD4300:
		strncat(g_mmi_buf_f54test_result, "-synaptics_4300",
			strlen("-synaptics_4300"));
		break;
	default:
		TS_LOG_ERR("failed to recognize ic_ver\n");
		break;
	}

	retval = synaptics_rmi4_irq_enable(IRQ_ON);
	sysfs_is_busy = true;
	f54->rmi4_data->reset_device(rmi4_data);
	atomic_set(&g_ts_data.state, TS_WORK);
	return 1;
exit:
	retval = synaptics_rmi4_irq_enable(IRQ_ON);
	sysfs_is_busy = true;
	f54->rmi4_data->reset_device(rmi4_data);
	strcat(g_mmi_buf_f54test_result, "0F-software_reason");
	TS_LOG_ERR("%s: Failed to run mmi test\n", __func__);
	atomic_set(&g_ts_data.state, TS_WORK);
	return 0;
}

static int read_debug_reg_status(unsigned char *buffer)
{
	int retval = 0;
	unsigned char command;
	char buf[6];

	TS_LOG_ERR("read_debug_reg_status_begin\n");
	retval = f54->fn_ptr->read(f54->rmi4_data,
				   0x0051, &command, sizeof(command));
	if (retval < 0) {
		TS_LOG_ERR("%s: Failed to read control 0x0051 \n", __func__);
		strcat(g_buf_debug_data, "Failed to read control 0x0051");
	} else {
		TS_LOG_INFO("Device Control1=0x%x\n", command);
		strcat(g_buf_debug_data, "Device Control1:");
		sprintf(buf, "0x%x ", command);
		strncat(g_buf_debug_data, buf, sizeof(buf));
	}
	retval = f54->fn_ptr->read(f54->rmi4_data,
				   0x0052, &command, sizeof(command));
	if (retval < 0) {
		TS_LOG_ERR("%s: Failed to read control 0x0052 \n", __func__);
		strcat(g_buf_debug_data, "Failed to read control 0x0052");
	} else {
		TS_LOG_INFO("Interrupt Enable=0x%x\n", command);
		strcat(g_buf_debug_data, "Interrupt Enable:");
		sprintf(buf, "0x%x ", command);
		strncat(g_buf_debug_data, buf, sizeof(buf));
	}

	retval = f54->fn_ptr->read(f54->rmi4_data,
				   0x0013, &command, sizeof(command));
	if (retval < 0) {
		TS_LOG_ERR("%s: Failed to read control 0x0013 \n", __func__);
		strcat(g_buf_debug_data, "Failed to read control 0x0013");
	} else {
		TS_LOG_INFO("Device Status=0x%x\n", command);
		strcat(g_buf_debug_data, "Device Status:");
		sprintf(buf, "0x%x ", command);
		strncat(g_buf_debug_data, buf, sizeof(buf));
	}

	retval = f54->fn_ptr->read(f54->rmi4_data,
				   0x0014, &command, sizeof(command));
	if (retval < 0) {
		TS_LOG_ERR("%s: Failed to read control 0x0014 \n", __func__);
		strcat(g_buf_debug_data, "Failed to read control 0x0014");
	} else {
		TS_LOG_INFO("Interrupt Status=0x%x\n", command);
		strcat(g_buf_debug_data, "Interrupt Status:");
		sprintf(buf, "0x%x ", command);
		strncat(g_buf_debug_data, buf, sizeof(buf));
		strncat(g_buf_debug_data, "\0", 1);
	}

	return retval;
}

static int read_debug_power_pin_status(unsigned char *buffer)
{
	int retval = 0;
	char buf[10];

	retval =
	    gpio_get_value(f54->rmi4_data->synaptics_chip_data->reset_gpio);
	if (retval < 0) {
		TS_LOG_ERR("failed to get reset_gpio %d\n", retval);
		strcat(g_buf_debug_data, "failed to get reset_gpio");
	} else {
		TS_LOG_INFO("reset_gpio=%d\n", retval);
		strcat(g_buf_debug_data, "reset_gpio value is:");
		sprintf(buf, "0x%x ", retval);
		strncat(g_buf_debug_data, buf, sizeof(buf));
	}
	retval = gpio_get_value(f54->rmi4_data->synaptics_chip_data->irq_gpio);
	if (retval < 0) {
		TS_LOG_ERR("failed to get irq_gpio %d\n", retval);
		strcat(g_buf_debug_data, "failed to get irq_gpio");
	} else {
		TS_LOG_INFO("irq_gpio=%d\n", retval);
		strcat(g_buf_debug_data, "irq_gpio value is:");
		sprintf(buf, "0x%x ", retval);
		strncat(g_buf_debug_data, buf, sizeof(buf));
	}

	retval =
	    gpio_get_value(f54->rmi4_data->synaptics_chip_data->vci_gpio_ctrl);
	if (retval < 0) {
		TS_LOG_ERR("failed to get vci_gpio_ctrl %d\n", retval);
		strcat(g_buf_debug_data, "failed to get vci_gpio_ctrl");
	} else {
		TS_LOG_INFO("vci_gpio_ctrl=%d\n", retval);
		strcat(g_buf_debug_data, "vci_gpio_ctrl value is:");
		sprintf(buf, "0x%x ", retval);
		strncat(g_buf_debug_data, buf, sizeof(buf));
	}

	retval =
	    gpio_get_value(f54->rmi4_data->synaptics_chip_data->
			   vddio_gpio_ctrl);
	if (retval < 0) {
		TS_LOG_ERR("failed to get vddio_gpio_ctrl %d\n", retval);
		strcat(g_buf_debug_data, "failed to get vddio_gpio_ctrl");
	} else {
		TS_LOG_INFO("vddio_gpio_ctrl=%d\n", retval);
		strcat(g_buf_debug_data, "vddio_gpio_ctrl value is:");
		sprintf(buf, "0x%x ", retval);
		strncat(g_buf_debug_data, buf, sizeof(buf));
	}

	strcat(g_buf_debug_data, "g_ts_data.state is:");
	sprintf(buf, "%d ", atomic_read(&g_ts_data.state));
	strncat(g_buf_debug_data, buf, sizeof(buf));

	return retval;
}

static ssize_t synaptics_rmi4_f54_debug_test_show(struct device *dev,
						  struct device_attribute *attr,
						  char *buf)
{
	int retval = 0;
	int len = 0;
	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;
	TS_LOG_INFO("begin debug test.\n");

	if ((TS_SLEEP == atomic_read(&g_ts_data.state))
	    || (TS_MMI_CAP_TEST == atomic_read(&g_ts_data.state))) {
		TS_LOG_INFO("tp state unsupport debug.g_ts_data.state is %d\n",
			    atomic_read(&g_ts_data.state));
		return 0;
	}
	atomic_set(&g_ts_data.state, TS_MMI_CAP_TEST);
	retval = mmi_runtest(F54_16BIT_IMAGE);
	if (retval) {
		TS_LOG_ERR("fail to do F54_16BIT_IMAGE test\n");
	}

	retval = read_debug_reg_status(g_buf_debug_data);
	if (retval < 0) {
		TS_LOG_ERR("fail to do read_debug_reg_status test\n");
	}
	retval = read_debug_power_pin_status(g_buf_debug_data);
	if (retval < 0) {
		TS_LOG_ERR("fail to do read_debug_power_pin_status test\n");
	}

	sysfs_is_busy = true;
	f54->rmi4_data->reset_device(rmi4_data);

	if (NULL != g_buf_debug_data) {
		len = strlen(g_buf_debug_data);
		memcpy(buf, g_buf_debug_data, len + 1);
		strcat(buf, "\0");
		TS_LOG_INFO("%s\n", buf);
	} else {
		TS_LOG_INFO("read debug data error\n");
	}
	if (NULL != g_buf_debug_data) {
		kfree(g_buf_debug_data);
	}
	atomic_set(&g_ts_data.state, TS_WORK);
	return len;
}

static ssize_t synaptics_rmi4_f54_mmi_test_result_show(struct device *dev,
						       struct device_attribute
						       *attr, char *buf)
{
	int len = 0;
	TS_LOG_INFO("%s begin \n", __func__);
	if (NULL != g_mmi_buf_f54test_result) {
		len = strlen(g_mmi_buf_f54test_result);
		memcpy(buf, g_mmi_buf_f54test_result, len + 1);
		strcat(buf, "\n");
	} else
		goto exit;

	if ((NULL != g_mmi_buf_f54raw_data)
	    && (NULL != g_mmi_highresistance_report)
	    && (NULL != g_mmi_maxmincapacitance_report)
	    && (NULL != g_mmi_RxtoRxshort_report)) {
		strcat(buf, g_mmi_buf_f54raw_data);
		strcat(buf, g_mmi_highresistance_report);
		strcat(buf, g_mmi_maxmincapacitance_report);
		strcat(buf, g_mmi_RxtoRxshort_report);
		strcat(buf, "\0");

		len =
		    strlen(g_mmi_buf_f54test_result) +
		    strlen(g_mmi_buf_f54raw_data) + 1 +
		    strlen(g_mmi_highresistance_report) +
		    strlen(g_mmi_maxmincapacitance_report)
		    + strlen(g_mmi_RxtoRxshort_report);
	}
exit:
	return len;
}

static ssize_t hw_synaptics_mmi_test_show(struct kobject *dev,
					  struct kobj_attribute *attr,
					  const char *buf)
{
	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;
	struct device *cdev = &rmi4_data->input_dev->dev;
	if (!cdev) {
		TS_LOG_ERR("device is null\n");
		return -EINVAL;
	}
	return synaptics_rmi4_f54_mmi_test_show(cdev, NULL, buf);
}

static ssize_t hw_synaptics_debug_test_show(struct kobject *dev,
					    struct kobj_attribute *attr,
					    const char *buf)
{
	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;
	struct device *cdev = &rmi4_data->input_dev->dev;
	if (!cdev) {
		TS_LOG_ERR("device is null\n");
		return -EINVAL;
	}
	return synaptics_rmi4_f54_debug_test_show(cdev, NULL, buf);
}

static ssize_t hw_synaptics_trigger_log_show(struct kobject *dev,
					     struct kobj_attribute *attr,
					     const char *buf)
{
	TS_LOG_ERR("g_synaptics_trigger_log_flag show is %d\n",
		   g_synaptics_trigger_log_flag);

	return sprintf(buf, "%d\n", g_synaptics_trigger_log_flag);
}

static ssize_t hw_synaptics_trigger_log_store(struct device *dev,
					      struct device_attribute *attr,
					      const char *buf, size_t count)
{
	int retval;
	unsigned long setting;

	retval = sstrtoul(buf, 10, &setting);
	if (retval)
		return retval;

	g_synaptics_trigger_log_flag = setting;

	TS_LOG_ERR("g_synaptics_trigger_log_flag store is %d\n",
		   g_synaptics_trigger_log_flag);

	return count;
}

static ssize_t hw_synaptics_mmi_test_result_show(struct kobject *dev,
						 struct kobj_attribute *attr,
						 char *buf)
{
	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;
	struct device *cdev = &rmi4_data->input_dev->dev;
	if (!cdev) {
		TS_LOG_ERR("device is null\n");
		return -EINVAL;
	}
	return synaptics_rmi4_f54_mmi_test_result_show(cdev, NULL, buf);
}

static struct kobj_attribute synaptics_mmi_test_v = {
	.attr = {.name = "tp_legacy_capacitance_test", .mode = 0664},
	.show = hw_synaptics_mmi_test_show,
	.store = NULL,
};

static struct kobj_attribute synaptics_mmi_test_result_v = {
	.attr = {.name = "tp_legacy_capacitance_data", .mode = 0444},
	.show = hw_synaptics_mmi_test_result_show,
	.store = NULL,
};

static struct kobj_attribute synaptics_debug_test_v = {
	.attr = {.name = "synaptics_debug_test", .mode = 0664},
	.show = hw_synaptics_debug_test_show,
	.store = NULL,
};

static struct kobj_attribute synaptics_trigger_log_v = {
	.attr = {.name = "synaptics_trigger_log", .mode = 0664},
	.show = hw_synaptics_trigger_log_show,
	.store = hw_synaptics_trigger_log_store,
};

static int add_synaptics_mmi_test_interfaces(struct device *dev)
{
	int error = 0;
	static int flag;
	struct kobject *properties_kobj;

	if (0 != flag) {
		return 0;
	}

	TS_LOG_INFO("%s: in!\n", __func__);
	properties_kobj = tp_get_touch_screen_obj();
	if (NULL == properties_kobj) {
		TS_LOG_ERR("Error, get kobj failed!\n");
		return -1;
	}

	/*add the node synaptics_mmi_test_result for apk to read */
	error =
	    sysfs_create_file(properties_kobj,
			      &synaptics_mmi_test_result_v.attr);
	if (error) {
		kobject_put(properties_kobj);
		TS_LOG_ERR("synaptics_mmi_test_result create file error = %d\n",
			   error);
		return -ENODEV;
	}

	/*add the node synaptics_mmi_test apk to write */
	error = sysfs_create_file(properties_kobj, &synaptics_mmi_test_v.attr);
	if (error) {
		kobject_put(properties_kobj);
		TS_LOG_ERR("synaptics_mmi_test create file error\n");
		return -ENODEV;
	}
	error =
	    sysfs_create_file(properties_kobj, &synaptics_debug_test_v.attr);
	if (error) {
		kobject_put(properties_kobj);
		TS_LOG_ERR("synaptics_mmi_test create file error\n");
		return -ENODEV;
	}
	error =
	    sysfs_create_file(properties_kobj, &synaptics_trigger_log_v.attr);
	if (error) {
		kobject_put(properties_kobj);
		TS_LOG_ERR("synaptics_trigger_log create file error\n");
		return -ENODEV;
	}

	flag = 1;
	return 0;
}


#endif

static ssize_t synaptics_rmi4_f54_resume_touch_store(struct device *dev,
						     struct device_attribute
						     *attr, const char *buf,
						     size_t count)
{
	int retval;
	unsigned long setting;

	retval = sstrtoul(buf, 10, &setting);
	if (retval)
		return retval;

	if (setting != 1)
		return -EINVAL;

	/*set_interrupt(false);*/

	return count;
}

static ssize_t synaptics_rmi4_f54_num_of_mapped_rx_show(struct device *dev,
							struct device_attribute
							*attr, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%u\n", f54->rx_assigned);
}

static ssize_t synaptics_rmi4_f54_num_of_mapped_tx_show(struct device *dev,
							struct device_attribute
							*attr, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%u\n", f54->tx_assigned);
}

simple_show_func_unsigned(query, num_of_rx_electrodes)
    simple_show_func_unsigned(query, num_of_tx_electrodes)
    simple_show_func_unsigned(query, has_image16)
    simple_show_func_unsigned(query, has_image8)
    simple_show_func_unsigned(query, has_baseline)
    simple_show_func_unsigned(query, clock_rate)
    simple_show_func_unsigned(query, touch_controller_family)
    simple_show_func_unsigned(query, has_pixel_touch_threshold_adjustment)
    simple_show_func_unsigned(query, has_sensor_assignment)
    simple_show_func_unsigned(query, has_interference_metric)
    simple_show_func_unsigned(query, has_sense_frequency_control)
    simple_show_func_unsigned(query, has_firmware_noise_mitigation)
    simple_show_func_unsigned(query, has_two_byte_report_rate)
    simple_show_func_unsigned(query, has_one_byte_report_rate)
    simple_show_func_unsigned(query, has_relaxation_control)
    simple_show_func_unsigned(query, curve_compensation_mode)
    simple_show_func_unsigned(query, has_iir_filter)
    simple_show_func_unsigned(query, has_cmn_removal)
    simple_show_func_unsigned(query, has_cmn_maximum)
    simple_show_func_unsigned(query, has_touch_hysteresis)
    simple_show_func_unsigned(query, has_edge_compensation)
    simple_show_func_unsigned(query, has_per_frequency_noise_control)
    simple_show_func_unsigned(query, has_signal_clarity)
    simple_show_func_unsigned(query, number_of_sensing_frequencies)

    show_store_func_unsigned(control, reg_0, no_relax)
    show_store_func_unsigned(control, reg_0, no_scan)
    show_store_func_unsigned(control, reg_1, bursts_per_cluster)
    show_store_func_unsigned(control, reg_2, saturation_cap)
    show_store_func_unsigned(control, reg_3, pixel_touch_threshold)
    show_store_func_unsigned(control, reg_4__6, rx_feedback_cap)
    show_store_func_unsigned(control, reg_4__6, low_ref_cap)
    show_store_func_unsigned(control, reg_4__6, low_ref_feedback_cap)
    show_store_func_unsigned(control, reg_4__6, low_ref_polarity)
    show_store_func_unsigned(control, reg_4__6, high_ref_cap)
    show_store_func_unsigned(control, reg_4__6, high_ref_feedback_cap)
    show_store_func_unsigned(control, reg_4__6, high_ref_polarity)
    show_store_func_unsigned(control, reg_7, cbc_cap)
    show_store_func_unsigned(control, reg_7, cbc_polarity)
    show_store_func_unsigned(control, reg_7, cbc_tx_carrier_selection)
    show_store_func_unsigned(control, reg_8__9, integration_duration)
    show_store_func_unsigned(control, reg_8__9, reset_duration)
    show_store_func_unsigned(control, reg_10, noise_sensing_bursts_per_image)
    show_store_func_unsigned(control, reg_12__13, slow_relaxation_rate)
    show_store_func_unsigned(control, reg_12__13, fast_relaxation_rate)
    show_store_func_unsigned(control, reg_14, rxs_on_xaxis)
    show_store_func_unsigned(control, reg_14, curve_comp_on_txs)
    show_store_func_unsigned(control, reg_20, disable_noise_mitigation)
    show_store_func_unsigned(control, reg_21, freq_shift_noise_threshold)
    show_store_func_unsigned(control, reg_22__26, medium_noise_threshold)
    show_store_func_unsigned(control, reg_22__26, high_noise_threshold)
    show_store_func_unsigned(control, reg_22__26, noise_density)
    show_store_func_unsigned(control, reg_22__26, frame_count)
    show_store_func_unsigned(control, reg_27, iir_filter_coef)
    show_store_func_unsigned(control, reg_28, quiet_threshold)
    show_store_func_unsigned(control, reg_29, cmn_filter_disable)
    show_store_func_unsigned(control, reg_30, cmn_filter_max)
    show_store_func_unsigned(control, reg_31, touch_hysteresis)
    show_store_func_unsigned(control, reg_32__35, rx_low_edge_comp)
    show_store_func_unsigned(control, reg_32__35, rx_high_edge_comp)
    show_store_func_unsigned(control, reg_32__35, tx_low_edge_comp)
    show_store_func_unsigned(control, reg_32__35, tx_high_edge_comp)
    show_store_func_unsigned(control, reg_41, no_signal_clarity)
    show_store_func_unsigned(control, reg_57, cbc_cap_0d)
    show_store_func_unsigned(control, reg_57, cbc_polarity_0d)
    show_store_func_unsigned(control, reg_57, cbc_tx_carrier_selection_0d)

    show_replicated_func_unsigned(control, reg_15, sensor_rx_assignment)
    show_replicated_func_unsigned(control, reg_16, sensor_tx_assignment)
    show_replicated_func_unsigned(control, reg_17, disable)
    show_replicated_func_unsigned(control, reg_17, filter_bandwidth)
    show_replicated_func_unsigned(control, reg_19, stretch_duration)
    show_replicated_func_unsigned(control, reg_38, noise_control_1)
    show_replicated_func_unsigned(control, reg_39, noise_control_2)
    show_replicated_func_unsigned(control, reg_40, noise_control_3)

    show_store_replicated_func_unsigned(control, reg_36, axis1_comp)
    show_store_replicated_func_unsigned(control, reg_37, axis2_comp)

static ssize_t synaptics_rmi4_f54_burst_count_show(struct device *dev,
						   struct device_attribute
						   *attr, char *buf)
{
	int retval;
	int size = 0;
	unsigned char ii;
	unsigned char *temp;
	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;

	mutex_lock(&f54->control_mutex);

	retval = f54->fn_ptr->read(rmi4_data,
				   f54->control.reg_17->address,
				   (unsigned char *)f54->control.reg_17->data,
				   f54->control.reg_17->length);
	if (retval < 0) {
		TS_LOG_ERR("%s: Failed to read control reg_17\n", __func__);
	}

	retval = f54->fn_ptr->read(rmi4_data,
				   f54->control.reg_18->address,
				   (unsigned char *)f54->control.reg_18->data,
				   f54->control.reg_18->length);
	if (retval < 0) {
		TS_LOG_ERR("%s: Failed to read control reg_18\n", __func__);
	}

	mutex_unlock(&f54->control_mutex);

	temp = buf;

	for (ii = 0; ii < f54->control.reg_17->length; ii++) {
		retval = snprintf(temp, PAGE_SIZE - size, "%u ", (1 << 8) *
				  f54->control.reg_17->data[ii].
				  burst_count_b8__10 +
				  f54->control.reg_18->data[ii].
				  burst_count_b0__7);
		if (retval < 0) {
			TS_LOG_ERR("%s: Faild to write output\n", __func__);
			return retval;
		}
		size += retval;
		temp += retval;
	}

	retval = snprintf(temp, PAGE_SIZE - size, "\n");
	if (retval < 0) {
		TS_LOG_ERR("%s: Faild to write null terminator\n", __func__);
		return retval;
	}

	return size + retval;
}

static ssize_t synaptics_rmi4_f54_data_read(struct file *data_file,
					    struct kobject *kobj,
					    struct bin_attribute *attributes,
					    char *buf, loff_t pos, size_t count)
{
	/*struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;*/

	mutex_lock(&f54->data_mutex);

	if (count < f54->report_size) {
		TS_LOG_ERR("%s: Report type %d data size (%d) too large\n",
			   __func__, f54->report_type, f54->report_size);
		mutex_unlock(&f54->data_mutex);
		return -EINVAL;
	}

	if (f54->report_data) {
		memcpy(buf, f54->report_data, f54->report_size);
		mutex_unlock(&f54->data_mutex);
		return f54->report_size;
	} else {
		TS_LOG_ERR("%s: Report type %d data not available\n", __func__,
			   f54->report_type);
		mutex_unlock(&f54->data_mutex);
		return -EINVAL;
	}
}

static int synaptics_rmi4_f54_set_sysfs(void)
{
	int retval;
	int reg_num;
	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;

	TS_LOG_INFO("%s: in!\n", __func__);
	f54->attr_dir = kobject_create_and_add("f54",
					       &rmi4_data->input_dev->dev.kobj);
	if (!f54->attr_dir) {
		TS_LOG_ERR("%s: Failed to create sysfs directory\n", __func__);
		goto exit_1;
	}

	retval = sysfs_create_bin_file(f54->attr_dir, &dev_report_data);
	if (retval < 0) {
		TS_LOG_ERR("%s: Failed to create sysfs bin file\n", __func__);
		goto exit_2;
	}

	retval = sysfs_create_group(f54->attr_dir, &attr_group);
	if (retval < 0) {
		TS_LOG_ERR("%s: Failed to create sysfs attributes\n", __func__);
		goto exit_3;
	}

	for (reg_num = 0; reg_num < ARRAY_SIZE(attrs_ctrl_regs); reg_num++) {
		if (attrs_ctrl_regs_exist[reg_num]) {
			retval = sysfs_create_group(f54->attr_dir,
						    &attrs_ctrl_regs[reg_num]);
			if (retval < 0) {
				TS_LOG_ERR
				    ("%s: Failed to create sysfs attributes\n",
				     __func__);
				goto exit_4;
			}
		}
	}

	retval = add_synaptics_mmi_test_interfaces(&rmi4_data->input_dev->dev);
	if (retval < 0) {
		TS_LOG_ERR("Error, synaptics_mmi_test init sysfs fail! \n");
		goto exit_4;
	}

	return 0;

exit_4:
	sysfs_remove_group(f54->attr_dir, &attr_group);

	for (reg_num--; reg_num >= 0; reg_num--)
		sysfs_remove_group(f54->attr_dir, &attrs_ctrl_regs[reg_num]);

exit_3:
	sysfs_remove_bin_file(f54->attr_dir, &dev_report_data);

exit_2:
	kobject_put(f54->attr_dir);

exit_1:
	return -ENODEV;
}

static int synaptics_rmi4_f54_set_ctrl(void)
{
	unsigned char length = 0;
	unsigned char reg_num = 0;
	unsigned char num_of_sensing_freqs;
	unsigned short reg_addr = f54->control_base_addr;
	struct f54_control *control = &f54->control;
	/*struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;*/

	num_of_sensing_freqs = f54->query.number_of_sensing_frequencies;

	/* control 0 */
	attrs_ctrl_regs_exist[reg_num] = true;
	control->reg_0 = kzalloc(sizeof(*(control->reg_0)), GFP_KERNEL);
	if (!control->reg_0)
		goto exit_no_mem;
	control->reg_0->address = reg_addr;
	reg_addr += sizeof(control->reg_0->data);
	reg_num++;

	/* control 1 */
	if ((f54->query.touch_controller_family == 0) ||
	    (f54->query.touch_controller_family == 1)) {
		attrs_ctrl_regs_exist[reg_num] = true;
		control->reg_1 = kzalloc(sizeof(*(control->reg_1)), GFP_KERNEL);
		if (!control->reg_1)
			goto exit_no_mem;
		control->reg_1->address = reg_addr;
		reg_addr += sizeof(control->reg_1->data);
	}
	reg_num++;

	/* control 2 */
	attrs_ctrl_regs_exist[reg_num] = true;
	control->reg_2 = kzalloc(sizeof(*(control->reg_2)), GFP_KERNEL);
	if (!control->reg_2)
		goto exit_no_mem;
	control->reg_2->address = reg_addr;
	reg_addr += sizeof(control->reg_2->data);
	reg_num++;

	/* control 3 */
	if (f54->query.has_pixel_touch_threshold_adjustment == 1) {
		attrs_ctrl_regs_exist[reg_num] = true;
		control->reg_3 = kzalloc(sizeof(*(control->reg_3)), GFP_KERNEL);
		if (!control->reg_3)
			goto exit_no_mem;
		control->reg_3->address = reg_addr;
		reg_addr += sizeof(control->reg_3->data);
	}
	reg_num++;

	/* controls 4 5 6 */
	if ((f54->query.touch_controller_family == 0) ||
	    (f54->query.touch_controller_family == 1)) {
		attrs_ctrl_regs_exist[reg_num] = true;
		control->reg_4__6 = kzalloc(sizeof(*(control->reg_4__6)),
					    GFP_KERNEL);
		if (!control->reg_4__6)
			goto exit_no_mem;
		control->reg_4__6->address = reg_addr;
		reg_addr += sizeof(control->reg_4__6->data);
	}
	reg_num++;

	/* control 7 */
	if (f54->query.touch_controller_family == 1) {
		attrs_ctrl_regs_exist[reg_num] = true;
		control->reg_7 = kzalloc(sizeof(*(control->reg_7)), GFP_KERNEL);
		if (!control->reg_7)
			goto exit_no_mem;
		control->reg_7->address = reg_addr;
		reg_addr += sizeof(control->reg_7->data);
	}
	reg_num++;

	/* controls 8 9 */
	if ((f54->query.touch_controller_family == 0) ||
	    (f54->query.touch_controller_family == 1)) {
		attrs_ctrl_regs_exist[reg_num] = true;
		control->reg_8__9 = kzalloc(sizeof(*(control->reg_8__9)),
					    GFP_KERNEL);
		if (!control->reg_8__9)
			goto exit_no_mem;
		control->reg_8__9->address = reg_addr;
		reg_addr += sizeof(control->reg_8__9->data);
	}
	reg_num++;

	/* control 10 */
	if (f54->query.has_interference_metric == 1) {
		attrs_ctrl_regs_exist[reg_num] = true;
		control->reg_10 = kzalloc(sizeof(*(control->reg_10)),
					  GFP_KERNEL);
		if (!control->reg_10)
			goto exit_no_mem;
		control->reg_10->address = reg_addr;
		reg_addr += sizeof(control->reg_10->data);
	}
	reg_num++;

	/* control 11 */
	if (f54->query.has_ctrl11 == 1) {
		attrs_ctrl_regs_exist[reg_num] = true;
		control->reg_11 = kzalloc(sizeof(*(control->reg_11)),
					  GFP_KERNEL);
		if (!control->reg_11)
			goto exit_no_mem;
		control->reg_11->address = reg_addr;
		reg_addr += sizeof(control->reg_11->data);
	}
	reg_num++;

	/* controls 12 13 */
	if (f54->query.has_relaxation_control == 1) {
		attrs_ctrl_regs_exist[reg_num] = true;
		control->reg_12__13 = kzalloc(sizeof(*(control->reg_12__13)),
					      GFP_KERNEL);
		if (!control->reg_12__13)
			goto exit_no_mem;
		control->reg_12__13->address = reg_addr;
		reg_addr += sizeof(control->reg_12__13->data);
	}
	reg_num++;

	/* controls 14 15 16 */
	if (f54->query.has_sensor_assignment == 1) {
		attrs_ctrl_regs_exist[reg_num] = true;

		control->reg_14 = kzalloc(sizeof(*(control->reg_14)),
					  GFP_KERNEL);
		if (!control->reg_14)
			goto exit_no_mem;
		control->reg_14->address = reg_addr;
		reg_addr += sizeof(control->reg_14->data);

		control->reg_15 = kzalloc(sizeof(*(control->reg_15)),
					  GFP_KERNEL);
		if (!control->reg_15)
			goto exit_no_mem;
		control->reg_15->length = f54->query.num_of_rx_electrodes;
		control->reg_15->data = kzalloc(control->reg_15->length *
						sizeof(*
						       (control->reg_15->data)),
						GFP_KERNEL);
		if (!control->reg_15->data)
			goto exit_no_mem;
		control->reg_15->address = reg_addr;
		reg_addr += control->reg_15->length;

		control->reg_16 = kzalloc(sizeof(*(control->reg_16)),
					  GFP_KERNEL);
		if (!control->reg_16)
			goto exit_no_mem;
		control->reg_16->length = f54->query.num_of_tx_electrodes;
		control->reg_16->data = kzalloc(control->reg_16->length *
						sizeof(*
						       (control->reg_16->data)),
						GFP_KERNEL);
		if (!control->reg_16->data)
			goto exit_no_mem;
		control->reg_16->address = reg_addr;
		reg_addr += control->reg_16->length;
	}
	reg_num++;

	/* controls 17 18 19 */
	if (f54->query.has_sense_frequency_control == 1) {
		attrs_ctrl_regs_exist[reg_num] = true;

		length = num_of_sensing_freqs;

		control->reg_17 = kzalloc(sizeof(*(control->reg_17)),
					  GFP_KERNEL);
		if (!control->reg_17)
			goto exit_no_mem;
		control->reg_17->length = length;
		control->reg_17->data = kzalloc(length *
						sizeof(*
						       (control->reg_17->data)),
						GFP_KERNEL);
		if (!control->reg_17->data)
			goto exit_no_mem;
		control->reg_17->address = reg_addr;
		reg_addr += length;

		control->reg_18 = kzalloc(sizeof(*(control->reg_18)),
					  GFP_KERNEL);
		if (!control->reg_18)
			goto exit_no_mem;
		control->reg_18->length = length;
		control->reg_18->data = kzalloc(length *
						sizeof(*
						       (control->reg_18->data)),
						GFP_KERNEL);
		if (!control->reg_18->data)
			goto exit_no_mem;
		control->reg_18->address = reg_addr;
		reg_addr += length;

		control->reg_19 = kzalloc(sizeof(*(control->reg_19)),
					  GFP_KERNEL);
		if (!control->reg_19)
			goto exit_no_mem;
		control->reg_19->length = length;
		control->reg_19->data = kzalloc(length *
						sizeof(*
						       (control->reg_19->data)),
						GFP_KERNEL);
		if (!control->reg_19->data)
			goto exit_no_mem;
		control->reg_19->address = reg_addr;
		reg_addr += length;
	}
	reg_num++;

	/* control 20 */
	attrs_ctrl_regs_exist[reg_num] = true;
	control->reg_20 = kzalloc(sizeof(*(control->reg_20)), GFP_KERNEL);
	if (!control->reg_20)
		goto exit_no_mem;
	control->reg_20->address = reg_addr;
	reg_addr += sizeof(control->reg_20->data);
	reg_num++;

	/* control 21 */
	if (f54->query.has_sense_frequency_control == 1) {
		attrs_ctrl_regs_exist[reg_num] = true;
		control->reg_21 = kzalloc(sizeof(*(control->reg_21)),
					  GFP_KERNEL);
		if (!control->reg_21)
			goto exit_no_mem;
		control->reg_21->address = reg_addr;
		reg_addr += sizeof(control->reg_21->data);
	}
	reg_num++;

	/* controls 22 23 24 25 26 */
	if (f54->query.has_firmware_noise_mitigation == 1) {
		attrs_ctrl_regs_exist[reg_num] = true;
		control->reg_22__26 = kzalloc(sizeof(*(control->reg_22__26)),
					      GFP_KERNEL);
		if (!control->reg_22__26)
			goto exit_no_mem;
		control->reg_22__26->address = reg_addr;
		reg_addr += sizeof(control->reg_22__26->data);
	}
	reg_num++;

	/* control 27 */
	if (f54->query.has_iir_filter == 1) {
		attrs_ctrl_regs_exist[reg_num] = true;
		control->reg_27 = kzalloc(sizeof(*(control->reg_27)),
					  GFP_KERNEL);
		if (!control->reg_27)
			goto exit_no_mem;
		control->reg_27->address = reg_addr;
		reg_addr += sizeof(control->reg_27->data);
	}
	reg_num++;

	/* control 28 */
	if (f54->query.has_firmware_noise_mitigation == 1) {
		attrs_ctrl_regs_exist[reg_num] = true;
		control->reg_28 = kzalloc(sizeof(*(control->reg_28)),
					  GFP_KERNEL);
		if (!control->reg_28)
			goto exit_no_mem;
		control->reg_28->address = reg_addr;
		reg_addr += sizeof(control->reg_28->data);
	}
	reg_num++;

	/* control 29 */
	if (f54->query.has_cmn_removal == 1) {
		attrs_ctrl_regs_exist[reg_num] = true;
		control->reg_29 = kzalloc(sizeof(*(control->reg_29)),
					  GFP_KERNEL);
		if (!control->reg_29)
			goto exit_no_mem;
		control->reg_29->address = reg_addr;
		reg_addr += sizeof(control->reg_29->data);
	}
	reg_num++;

	/* control 30 */
	if (f54->query.has_cmn_maximum == 1) {
		attrs_ctrl_regs_exist[reg_num] = true;
		control->reg_30 = kzalloc(sizeof(*(control->reg_30)),
					  GFP_KERNEL);
		if (!control->reg_30)
			goto exit_no_mem;
		control->reg_30->address = reg_addr;
		reg_addr += sizeof(control->reg_30->data);
	}
	reg_num++;

	/* control 31 */
	if (f54->query.has_touch_hysteresis == 1) {
		attrs_ctrl_regs_exist[reg_num] = true;
		control->reg_31 = kzalloc(sizeof(*(control->reg_31)),
					  GFP_KERNEL);
		if (!control->reg_31)
			goto exit_no_mem;
		control->reg_31->address = reg_addr;
		reg_addr += sizeof(control->reg_31->data);
	}
	reg_num++;

	/* controls 32 33 34 35 */
	if (f54->query.has_edge_compensation == 1) {
		attrs_ctrl_regs_exist[reg_num] = true;
		control->reg_32__35 = kzalloc(sizeof(*(control->reg_32__35)),
					      GFP_KERNEL);
		if (!control->reg_32__35)
			goto exit_no_mem;
		control->reg_32__35->address = reg_addr;
		reg_addr += sizeof(control->reg_32__35->data);
	}
	reg_num++;

	/* control 36 */
	if ((f54->query.curve_compensation_mode == 1) ||
	    (f54->query.curve_compensation_mode == 2)) {
		attrs_ctrl_regs_exist[reg_num] = true;

		if (f54->query.curve_compensation_mode == 1) {
			length = max(f54->query.num_of_rx_electrodes,
				     f54->query.num_of_tx_electrodes);
		} else if (f54->query.curve_compensation_mode == 2) {
			length = f54->query.num_of_rx_electrodes;
		}

		control->reg_36 = kzalloc(sizeof(*(control->reg_36)),
					  GFP_KERNEL);
		if (!control->reg_36)
			goto exit_no_mem;
		control->reg_36->length = length;
		control->reg_36->data = kzalloc(length *
						sizeof(*
						       (control->reg_36->data)),
						GFP_KERNEL);
		if (!control->reg_36->data)
			goto exit_no_mem;
		control->reg_36->address = reg_addr;
		reg_addr += length;
	}
	reg_num++;

	/* control 37 */
	if (f54->query.curve_compensation_mode == 2) {
		attrs_ctrl_regs_exist[reg_num] = true;

		control->reg_37 = kzalloc(sizeof(*(control->reg_37)),
					  GFP_KERNEL);
		if (!control->reg_37)
			goto exit_no_mem;
		control->reg_37->length = f54->query.num_of_tx_electrodes;
		control->reg_37->data = kzalloc(control->reg_37->length *
						sizeof(*
						       (control->reg_37->data)),
						GFP_KERNEL);
		if (!control->reg_37->data)
			goto exit_no_mem;

		control->reg_37->address = reg_addr;
		reg_addr += control->reg_37->length;
	}
	reg_num++;

	/* controls 38 39 40 */
	if (f54->query.has_per_frequency_noise_control == 1) {
		attrs_ctrl_regs_exist[reg_num] = true;

		control->reg_38 = kzalloc(sizeof(*(control->reg_38)),
					  GFP_KERNEL);
		if (!control->reg_38)
			goto exit_no_mem;
		control->reg_38->length = num_of_sensing_freqs;
		control->reg_38->data = kzalloc(control->reg_38->length *
						sizeof(*
						       (control->reg_38->data)),
						GFP_KERNEL);
		if (!control->reg_38->data)
			goto exit_no_mem;
		control->reg_38->address = reg_addr;
		reg_addr += control->reg_38->length;

		control->reg_39 = kzalloc(sizeof(*(control->reg_39)),
					  GFP_KERNEL);
		if (!control->reg_39)
			goto exit_no_mem;
		control->reg_39->length = num_of_sensing_freqs;
		control->reg_39->data = kzalloc(control->reg_39->length *
						sizeof(*
						       (control->reg_39->data)),
						GFP_KERNEL);
		if (!control->reg_39->data)
			goto exit_no_mem;
		control->reg_39->address = reg_addr;
		reg_addr += control->reg_39->length;

		control->reg_40 = kzalloc(sizeof(*(control->reg_40)),
					  GFP_KERNEL);
		if (!control->reg_40)
			goto exit_no_mem;
		control->reg_40->length = num_of_sensing_freqs;
		control->reg_40->data = kzalloc(control->reg_40->length *
						sizeof(*
						       (control->reg_40->data)),
						GFP_KERNEL);
		if (!control->reg_40->data)
			goto exit_no_mem;
		control->reg_40->address = reg_addr;
		reg_addr += control->reg_40->length;
	}
	reg_num++;

	/* control 41 */
	if (f54->query.has_signal_clarity == 1) {
		attrs_ctrl_regs_exist[reg_num] = true;
		control->reg_41 = kzalloc(sizeof(*(control->reg_41)),
					  GFP_KERNEL);
		if (!control->reg_41)
			goto exit_no_mem;
		control->reg_41->address = reg_addr;
		reg_addr += sizeof(control->reg_41->data);
	}
	reg_num++;

	/* control 42 */
	if (f54->query.has_variance_metric == 1)
		reg_addr += CONTROL_42_SIZE;

	/* controls 43 44 45 46 47 48 49 50 51 52 53 54 */
	if (f54->query.has_multi_metric_state_machine == 1)
		reg_addr += CONTROL_43_54_SIZE;

	/* controls 55 56 */
	if (f54->query.has_0d_relaxation_control == 1)
		reg_addr += CONTROL_55_56_SIZE;

	/* control 57 */
	if (f54->query.has_0d_acquisition_control == 1) {
		attrs_ctrl_regs_exist[reg_num] = true;
		control->reg_57 = kzalloc(sizeof(*(control->reg_57)),
					  GFP_KERNEL);
		if (!control->reg_57)
			goto exit_no_mem;
		control->reg_57->address = reg_addr;
		reg_addr += sizeof(control->reg_57->data);
	}
	reg_num++;

	/* control 58 */
	if (f54->query.has_0d_acquisition_control == 1)
		reg_addr += CONTROL_58_SIZE;

	/* control 59 */
	if (f54->query.has_h_blank == 1)
		reg_addr += CONTROL_59_SIZE;

	/* controls 60 61 62 */
	if ((f54->query.has_h_blank == 1) ||
	    (f54->query.has_v_blank == 1) || (f54->query.has_long_h_blank == 1))
		reg_addr += CONTROL_60_62_SIZE;

	/* control 63 */
	if ((f54->query.has_h_blank == 1) ||
	    (f54->query.has_v_blank == 1) ||
	    (f54->query.has_long_h_blank == 1) ||
	    (f54->query.has_slew_metric == 1) ||
	    (f54->query.has_slew_option == 1) ||
	    (f54->query.has_noise_mitigation2 == 1))
		reg_addr += CONTROL_63_SIZE;

	/* controls 64 65 66 67 */
	if (f54->query.has_h_blank == 1)
		reg_addr += CONTROL_64_67_SIZE * 7;
	else if ((f54->query.has_v_blank == 1) ||
		 (f54->query.has_long_h_blank == 1))
		reg_addr += CONTROL_64_67_SIZE;

	/* controls 68 69 70 71 72 73 */
	if ((f54->query.has_h_blank == 1) ||
	    (f54->query.has_v_blank == 1) || (f54->query.has_long_h_blank == 1))
		reg_addr += CONTROL_68_73_SIZE;

	/* control 74 */
	if (f54->query.has_slew_metric == 1)
		reg_addr += CONTROL_74_SIZE;

	/* control 75 */
	if (f54->query.has_enhanced_stretch == 1)
		reg_addr += num_of_sensing_freqs;

	/* control 76 */
	if (f54->query.has_startup_fast_relaxation == 1)
		reg_addr += CONTROL_76_SIZE;

	/* controls 77 78 */
	if (f54->query.has_esd_control == 1)
		reg_addr += CONTROL_77_78_SIZE;

	/* controls 79 80 81 82 83 */
	if (f54->query.has_noise_mitigation2 == 1)
		reg_addr += CONTROL_79_83_SIZE;

	/* controls 84 85 */
	if (f54->query.has_energy_ratio_relaxation == 1)
		reg_addr += CONTROL_84_85_SIZE;

	/* control 86 */
	if ((f54->query.has_query13 == 1) && (f54->query.has_ctrl86 == 1))
		reg_addr += CONTROL_86_SIZE;

	/* control 87 */
	if ((f54->query.has_query13 == 1) && (f54->query.has_ctrl87 == 1))
		reg_addr += CONTROL_87_SIZE;

	/* control 88 */
	if (f54->query.has_ctrl88 == 1) {
		control->reg_88 = kzalloc(sizeof(*(control->reg_88)),
					  GFP_KERNEL);
		if (!control->reg_88)
			goto exit_no_mem;
		control->reg_88->address = reg_addr;
		/*warn repprted in hisi fortify_report check,delete it*/
		/*reg_addr += sizeof(control->reg_88->data);*/
	}

	return 0;

exit_no_mem:
	TS_LOG_ERR("%s: Failed to alloc mem for control registers\n", __func__);
	return -ENOMEM;
}

static int synaptics_rmi4_f54_status_work(struct work_struct *work)
{
	int retval;
	unsigned char report_index[2];
	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;
	int i = 0;
	unsigned int report_times_max = 0;
	unsigned int report_size_temp = MAX_I2C_MSG_LENS;
	unsigned char *report_data_temp = NULL;
	if (f54->status != STATUS_BUSY)
		return -EINVAL;

	set_report_size();
	if (f54->report_size == 0) {
		TS_LOG_ERR("%s: Report data size = 0\n", __func__);
		retval = -EINVAL;
		goto error_exit;
	}

	if (f54->data_buffer_size < f54->report_size) {
		mutex_lock(&f54->data_mutex);
		if (f54->data_buffer_size)
			kfree(f54->report_data);
		f54->report_data = kzalloc(f54->report_size, GFP_KERNEL);
		if (!f54->report_data) {
			TS_LOG_ERR("%s: Failed to alloc mem for data buffer\n",
				   __func__);
			f54->data_buffer_size = 0;
			mutex_unlock(&f54->data_mutex);
			retval = -ENOMEM;
			goto error_exit;
		}
		f54->data_buffer_size = f54->report_size;
		mutex_unlock(&f54->data_mutex);
	}
	report_times_max = f54->report_size / MAX_I2C_MSG_LENS;
	if (f54->report_size % MAX_I2C_MSG_LENS != 0) {
		report_times_max += 1;
	}
	report_index[0] = 0;
	report_index[1] = 0;

	retval = f54->fn_ptr->write(rmi4_data,
				    f54->data_base_addr +
				    DATA_REPORT_INDEX_OFFSET, report_index,
				    sizeof(report_index));
	if (retval < 0) {
		TS_LOG_ERR("%s: Failed to write report data index\n", __func__);
		retval = -EINVAL;
		goto error_exit;
	}
	mutex_lock(&f54->data_mutex);
	/* Point to the block data about to transfer */
	report_data_temp = f54->report_data;
	for (i = 0; i < report_times_max; i++) {

		if (i == (report_times_max - 1)) {
			/* The last time transfer the rest of the block data */
			report_size_temp = f54->report_size % MAX_I2C_MSG_LENS;
		}
		retval = f54->fn_ptr->read(rmi4_data,
					   f54->data_base_addr +
					   DATA_REPORT_DATA_OFFSET,
					   report_data_temp, report_size_temp);
		if (retval < 0) {
			TS_LOG_ERR("%s: Failed to read report data\n",
				   __func__);
			retval = -EINVAL;
			mutex_unlock(&f54->data_mutex);
			goto error_exit;
		}
		/* Point to the next 256bytes data */
		report_data_temp += MAX_I2C_MSG_LENS;
	}
	mutex_unlock(&f54->data_mutex);
	retval = STATUS_IDLE;

#ifdef RAW_HEX
	print_raw_hex_report();
#endif

#ifdef HUMAN_READABLE
	print_image_report();
#endif

error_exit:
	mutex_lock(&f54->status_mutex);
	f54->status = retval;
	mutex_unlock(&f54->status_mutex);

	return retval;
}

static int synaptics_rmi4_f54_attention(void)
{
	return synaptics_rmi4_f54_status_work(NULL);
}

static void synaptics_rmi4_f54_set_regs(struct synaptics_rmi4_data *rmi4_data,
					struct synaptics_rmi4_fn_desc *fd,
					unsigned int intr_count,
					unsigned char page)
{
	unsigned char ii;
	unsigned char intr_offset;

	f54->query_base_addr = fd->query_base_addr | (page << 8);
	f54->control_base_addr = fd->ctrl_base_addr | (page << 8);
	f54->data_base_addr = fd->data_base_addr | (page << 8);
	f54->command_base_addr = fd->cmd_base_addr | (page << 8);

	f54->intr_reg_num = (intr_count + 7) / 8;
	if (f54->intr_reg_num != 0)
		f54->intr_reg_num -= 1;

	f54->intr_mask = 0;
	intr_offset = intr_count % 8;
	for (ii = intr_offset;
	     ii < ((fd->intr_src_count & MASK_3BIT) + intr_offset); ii++) {
		f54->intr_mask |= 1 << ii;
	}

	return;
}

static void synaptics_rmi5_f55_init(struct synaptics_rmi4_data *rmi4_data)
{
	int retval;
	unsigned char ii;
	unsigned char rx_electrodes = f54->query.num_of_rx_electrodes;
	unsigned char tx_electrodes = f54->query.num_of_tx_electrodes;

	retval = f54->fn_ptr->read(rmi4_data,
				   f55->query_base_addr,
				   f55->query.data, sizeof(f55->query.data));
	if (retval < 0) {
		TS_LOG_ERR("%s: Failed to read f55 query registers\n",
			   __func__);
		return;
	}

	if (!f55->query.has_sensor_assignment)
		return;

	f55->rx_assignment = kzalloc(rx_electrodes, GFP_KERNEL);
	if (f55->rx_assignment == NULL) {
		TS_LOG_ERR("%s:kzalloc failed\n",__func__);
		return;
	}
	f55->tx_assignment = kzalloc(tx_electrodes, GFP_KERNEL);
	if (f55->tx_assignment == NULL) {
		TS_LOG_ERR("%s:kzalloc failed\n",__func__);
		return;
	}
	retval = f54->fn_ptr->read(rmi4_data,
				   f55->control_base_addr +
				   SENSOR_RX_MAPPING_OFFSET, f55->rx_assignment,
				   rx_electrodes);
	if (retval < 0) {
		TS_LOG_ERR("%s: Failed to read f55 rx assignment\n", __func__);
		return;
	}

	retval = f54->fn_ptr->read(rmi4_data,
				   f55->control_base_addr +
				   SENSOR_TX_MAPPING_OFFSET, f55->tx_assignment,
				   tx_electrodes);
	if (retval < 0) {
		TS_LOG_ERR("%s: Failed to read f55 tx assignment\n", __func__);
		return;
	}

	f54->rx_assigned = 0;
	for (ii = 0; ii < rx_electrodes; ii++) {
		if (f55->rx_assignment[ii] != 0xff)
			f54->rx_assigned++;
	}

	f54->tx_assigned = 0;
	for (ii = 0; ii < tx_electrodes; ii++) {
		if (f55->tx_assignment[ii] != 0xff)
			f54->tx_assigned++;
	}

	return;
}

static void synaptics_rmi4_f55_set_regs(struct synaptics_rmi4_data *rmi4_data,
					struct synaptics_rmi4_fn_desc *fd,
					unsigned char page)
{
	f55 = kzalloc(sizeof(*f55), GFP_KERNEL);
	if (!f55) {
		TS_LOG_ERR("%s: Failed to alloc mem for f55\n", __func__);
		return;
	}

	f55->query_base_addr = fd->query_base_addr | (page << 8);
	f55->control_base_addr = fd->ctrl_base_addr | (page << 8);
	f55->data_base_addr = fd->data_base_addr | (page << 8);
	f55->command_base_addr = fd->cmd_base_addr | (page << 8);

	return;
}

static int match_module_name(const char *module_name)
{
	TS_LOG_INFO("%s: module_name = %s\n", __func__, module_name);

	if (strcmp(module_name, "oflim") == 0)	/*oflim*/{
		if (!strcmp(g_ts_data.product_name, "g760s")) {
			FullRawMaxCap = FullRawMaxCap_oflim_g760s;
			FullRawMinCap = FullRawMinCap_oflim_g760s;

			FullRawCapUpperLimit = FullRawCapUpperLimit_oflim_g760s;
			FullRawCapLowerLimit = FullRawCapLowerLimit_oflim_g760s;

			HighResistanceUpperLimit =
			    HighResistanceUpperLimit_oflim_g760s;
			HighResistanceLowerLimit =
			    HighResistanceLowerLimit_oflim_g760s;

			RxDiagonalUpperLimit = RxDiagonalUpperLimit_oflim_g760s;
			RxDiagonalLowerLimit = RxDiagonalLowerLimit_oflim_g760s;

		} else {
			FullRawMaxCap = FullRawMaxCap_oflim;
			FullRawMinCap = FullRawMinCap_oflim;

			FullRawCapUpperLimit = FullRawCapUpperLimit_oflim;
			FullRawCapLowerLimit = FullRawCapLowerLimit_oflim;

			HighResistanceUpperLimit =
			    HighResistanceUpperLimit_oflim;
			HighResistanceLowerLimit =
			    HighResistanceLowerLimit_oflim;

			RxDiagonalUpperLimit = RxDiagonalUpperLimit_oflim;
			RxDiagonalLowerLimit = RxDiagonalLowerLimit_oflim;
		}
		return 0;

	} else if (strcmp(module_name, "lensone") == 0)	/*lensone*/{
		if (!strcmp(g_ts_data.product_name, "g760s")) {
			FullRawMaxCap = FullRawMaxCap_lensone_g760s;
			FullRawMinCap = FullRawMinCap_lensone_g760s;

			FullRawCapUpperLimit =
			    FullRawCapUpperLimit_lensone_760s;
			FullRawCapLowerLimit =
			    FullRawCapLowerLimit_lensone_g760s;

			HighResistanceUpperLimit =
			    HighResistanceUpperLimit_lensone_g760s;
			HighResistanceLowerLimit =
			    HighResistanceLowerLimit_lensone_g760s;

			RxDiagonalUpperLimit =
			    RxDiagonalUpperLimit_lensone_g760s;
			RxDiagonalLowerLimit =
			    RxDiagonalLowerLimit_lensone_g760s;

		} else {
			FullRawMaxCap = FullRawMaxCap_lensone;
			FullRawMinCap = FullRawMinCap_lensone;

			FullRawCapUpperLimit = FullRawCapUpperLimit_lensone;
			FullRawCapLowerLimit = FullRawCapLowerLimit_lensone;

			HighResistanceUpperLimit =
			    HighResistanceUpperLimit_lensone;
			HighResistanceLowerLimit =
			    HighResistanceLowerLimit_lensone;

			RxDiagonalUpperLimit = RxDiagonalUpperLimit_lensone;
			RxDiagonalLowerLimit = RxDiagonalLowerLimit_lensone;
		}
		return 0;

	} else if (strcmp(module_name, "GIS") == 0)	/*GIS*/{
		FullRawMaxCap = FullRawMaxCap_GIS;
		FullRawMinCap = FullRawMinCap_GIS;

		FullRawCapUpperLimit = FullRawCapUpperLimit_GIS;
		FullRawCapLowerLimit = FullRawCapLowerLimit_GIS;

		HighResistanceUpperLimit = HighResistanceUpperLimit_GIS;
		HighResistanceLowerLimit = HighResistanceLowerLimit_GIS;

		RxDiagonalUpperLimit = RxDiagonalUpperLimit_GIS;
		RxDiagonalLowerLimit = RxDiagonalLowerLimit_GIS;

		return 0;

	} else if (strcmp(module_name, "YASSY") == 0)	/*YASSY*/{
		FullRawMaxCap = FullRawMaxCap_YASSY;
		FullRawMinCap = FullRawMinCap_YASSY;

		FullRawCapUpperLimit = FullRawCapUpperLimit_YASSY;
		FullRawCapLowerLimit = FullRawCapLowerLimit_YASSY;

		HighResistanceUpperLimit = HighResistanceUpperLimit_YASSY;
		HighResistanceLowerLimit = HighResistanceLowerLimit_YASSY;

		RxDiagonalUpperLimit = RxDiagonalUpperLimit_YASSY;
		RxDiagonalLowerLimit = RxDiagonalLowerLimit_YASSY;

		return 0;

	} else {
		TS_LOG_ERR("%s: Failed to match module_name \n", __func__);
		return -1;
	}

}


int synaptics_rmi4_f54_s3207_init(struct synaptics_rmi4_data *rmi4_data,
				  const char *module_name)
{
	int retval;
	unsigned short ii;
	unsigned char page;
	unsigned char intr_count = 0;
	bool f54found = false;
	bool f55found = false;
	struct synaptics_rmi4_fn_desc rmi_fd;
	TS_LOG_INFO("%s: enter\n", __func__);

	retval = match_module_name(module_name);
	if (retval < 0) {
		retval = -ENOMEM;
		goto exit;
	}

	f54 = kzalloc(sizeof(*f54), GFP_KERNEL);
	if (!f54) {
		TS_LOG_ERR("%s: Failed to alloc mem for f54\n", __func__);
		retval = -ENOMEM;
		goto exit;
	}

	f54->fn_ptr = kzalloc(sizeof(*(f54->fn_ptr)), GFP_KERNEL);
	if (!f54->fn_ptr) {
		TS_LOG_ERR("%s: Failed to alloc mem for fn_ptr\n", __func__);
		retval = -ENOMEM;
		goto exit_free_f54;
	}

	f54->rmi4_data = rmi4_data;
	f54->fn_ptr->read = rmi4_data->i2c_read;
	f54->fn_ptr->write = rmi4_data->i2c_write;
	f54->fn_ptr->enable = rmi4_data->irq_enable;

	for (page = 0; page < PAGES_TO_SERVICE; page++) {
		for (ii = PDT_START; ii > PDT_END; ii -= PDT_ENTRY_SIZE) {
			ii |= (page << 8);

			retval = f54->fn_ptr->read(rmi4_data,
						   ii,
						   (unsigned char *)&rmi_fd,
						   sizeof(rmi_fd));
			if (retval < 0)
				goto exit_free_mem;

			if (!rmi_fd.fn_number)
				break;

			switch (rmi_fd.fn_number) {
			case SYNAPTICS_RMI4_F54:
				synaptics_rmi4_f54_set_regs(rmi4_data,
							    &rmi_fd, intr_count,
							    page);
				f54found = true;
				break;
			case SYNAPTICS_RMI4_F55:
				synaptics_rmi4_f55_set_regs(rmi4_data,
							    &rmi_fd, page);
				f55found = true;
				break;
			default:
				break;
			}

			if (f54found && f55found)
				goto pdt_done;

			intr_count += (rmi_fd.intr_src_count & MASK_3BIT);
		}
	}

	if (!f54found) {
		TS_LOG_INFO("%s: line(%d)\n", __func__, __LINE__);
		retval = -ENODEV;
		goto exit_free_mem;
	}

pdt_done:
	retval = f54->fn_ptr->read(rmi4_data,
				   f54->query_base_addr,
				   f54->query.data, sizeof(f54->query.data));
	if (retval < 0) {
		TS_LOG_ERR("%s: Failed to read f54 query registers\n",
			   __func__);
		goto exit_free_mem;
	}

	f54->rx_assigned = f54->query.num_of_rx_electrodes;
	f54->tx_assigned = f54->query.num_of_tx_electrodes;

	retval = synaptics_rmi4_f54_set_ctrl();
	if (retval < 0) {
		TS_LOG_ERR("%s: Failed to set up f54 control registers\n",
			   __func__);
		goto exit_free_control;
	}

	if (f55found)
		synaptics_rmi5_f55_init(rmi4_data);

	mutex_init(&f54->status_mutex);
	mutex_init(&f54->data_mutex);
	mutex_init(&f54->control_mutex);
/*Add synaptics capacitor test function */
#if 1
	TS_LOG_INFO("%s: sysfs_is_busy = %d\n", __func__, sysfs_is_busy);
	if (!sysfs_is_busy) {
		retval = synaptics_rmi4_f54_set_sysfs();
		if (retval < 0) {
			TS_LOG_ERR("%s: Failed to create sysfs entries\n",
				   __func__);
			goto exit_sysfs;
		}
		sysfs_is_busy = false;
	}
#endif
	f54->status_workqueue =
	    create_singlethread_workqueue("f54_status_workqueue");
	INIT_DELAYED_WORK(&f54->status_work, synaptics_rmi4_f54_status_work);

#ifdef WATCHDOG_HRTIMER
	/* Watchdog timer to catch unanswered get report commands */
	hrtimer_init(&f54->watchdog, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
	f54->watchdog.function = get_report_timeout;

	/* Work function to do actual cleaning up */
	INIT_WORK(&f54->timeout_work, timeout_set_status);
#endif

	f54->status = STATUS_IDLE;

	return 0;

exit_sysfs:
	kfree(f55->rx_assignment);
	kfree(f55->tx_assignment);

exit_free_control:
	free_control_mem();

exit_free_mem:
	kfree(f55);
	kfree(f54->fn_ptr);

exit_free_f54:
	kfree(f54);
	f54 = NULL;

exit:
	return retval;
}

#if 0
static void synaptics_rmi4_f54_remove(struct synaptics_rmi4_data *rmi4_data)
{
	if (!f54)
		goto exit;

#ifdef WATCHDOG_HRTIMER
	hrtimer_cancel(&f54->watchdog);
#endif

	cancel_delayed_work_sync(&f54->status_work);
	flush_workqueue(f54->status_workqueue);
	destroy_workqueue(f54->status_workqueue);

/*Add synaptics capacitor test function */
	if (!sysfs_is_busy)
		remove_sysfs();

	kfree(f55->rx_assignment);
	kfree(f55->tx_assignment);

	free_control_mem();

	kfree(f55);

	if (f54->data_buffer_size)
		kfree(f54->report_data);

	kfree(f54->fn_ptr);
	kfree(f54);
	f54 = NULL;

/*move free action to module_exit,because the cap test
 is complexity,I change this to other place,but panic always
 happened,so move to module exit for safety*/
exit:
	complete(&f54_remove_complete);

	return;
}
#endif
